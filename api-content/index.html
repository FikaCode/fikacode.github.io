{"posts":[{"title":"linux 更改时间为北京时间","content":"1. 删除自带的localtime rm -rf /etc/localtime 2. 创建软链接到localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime ","link":"https://fikacode.github.io/post/setLinuxBeijingZone/"},{"title":"获取任何一个类的VO","content":"package com.auth.frame.common.Utils; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.BeanUtils; import java.lang.reflect.Field; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; /** * @ClassName DTOVOUtil * @Author WFS * @Date 2020/1/20 16:24 */ @Slf4j public class DTOToVOUtil { @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T getVo(T c, String necessary, String exception) { if (necessary == null || &quot;&quot;.equals(necessary.replaceAll(&quot; &quot;, &quot;&quot;))) { necessary = &quot;&quot;; } if (exception == null || &quot;&quot;.equals(exception.replaceAll(&quot; &quot;, &quot;&quot;))) { exception = &quot;&quot;; } necessary = necessary.replaceAll(&quot; &quot;, &quot;&quot;); exception = exception.replaceAll(&quot; &quot;, &quot;&quot;); List&lt;String&gt; nl; List&lt;String&gt; e = Arrays.asList(exception.split(&quot;,&quot;)); if (&quot;&quot;.equals(necessary)) { nl = Stream.of(c.getClass().getDeclaredFields()).map(Field::getName).collect(Collectors.toList()); } else { nl = Arrays.asList(necessary.split(&quot;,&quot;)); } List&lt;String&gt; n = nl.stream().filter(ele -&gt; e.stream().noneMatch(ele::equals)).collect(Collectors.toList()); try { Object cn = Class.forName(c.getClass().getName()).newInstance(); String[] ig = Stream.of(c.getClass().getDeclaredFields()).filter(ele -&gt; n.stream().noneMatch(ele.getName()::equals)).map(Field::getName).toArray(String[]::new); BeanUtils.copyProperties(c, cn, ig); return (T) cn; } catch (Exception exp) { log.error(&quot;获取VO失败&quot;, exp); return null; } } } 使用说明 参数necessary是一个字符串，如果是null或者&quot;&quot;则默认包含所有，exception 过滤的字符串，如果为null或者&quot;&quot;，则不过滤。比如：实体A，包含name，value, id三个属性，getVo(A, &quot;name&quot;, null),则获得一个只有name值的A；getVo(A, null, &quot;value,id&quot;)获得相同的结果；getVo(A, null, &quot;name, value&quot;)，获得一个A，且把A的属性name和value置为null。 ","link":"https://fikacode.github.io/post/javaGetAnyVo/"},{"title":"Maven 添加第三方jar包","content":"maven 添加第三方jar包 &lt;dependency&gt; &lt;groupId&gt;com.km.studio&lt;/groupId&gt; &lt;artifactId&gt;auth&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/lib/auth.jar&lt;/systemPath&gt; &lt;/dependency&gt; ${project.basedir} 代表项目根目录，即lib和src同级 jar方式打包第三方jar包 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; war方式打包第三方jar包 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;lib&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/lib/&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ","link":"https://fikacode.github.io/post/mavenAddExtraJar/"},{"title":"Java 断点续传下载文件","content":"来自网上。 String filePath = downLoadFile + pathSeparator + fileName; InputStream inputStream = null; OutputStream out = null; try { File file = new File(filePath); Long fSize = Long.parseLong(String.valueOf(file.length())); response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/x-download&quot;); response.setHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;); response.setHeader(&quot;Content-Length&quot;, String.valueOf(fSize)); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + new String(fileName.getBytes(&quot;utf-8&quot;), &quot;ISO8859-1&quot;)); inputStream = new FileInputStream(filePath); Long pos = 0L; if (null != request.getHeader(&quot;Range&quot;)) { // 断点续传 response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); try { pos = Long.valueOf(request.getHeader(&quot;Range&quot;).replaceAll(&quot;bytes=&quot;, &quot;&quot;).replaceAll(&quot;-&quot;, &quot;&quot;)); } catch (NumberFormatException e) { pos = 0L; } } out = response.getOutputStream(); String contentRange = &quot;bytes &quot; + pos + &quot;&quot; + &quot;-&quot; + (fSize - 1) + &quot;&quot; + &quot;/&quot; + fSize + &quot;&quot;; response.setHeader(&quot;Content-Range&quot;, contentRange); //跳过 pos 个文件字节 Long offset = pos; while (offset &gt; 0) { Long fileAt = inputStream.skip(offset); if (fileAt == -1) { throw new RuntimeException(&quot;文件断点设置失败！&quot;); } offset -= fileAt; } byte[] buffer = new byte[1024 * 10]; int length; while ((length = inputStream.read(buffer, 0, buffer.length)) != -1) { out.write(buffer, 0, length); } } catch (Exception e) { LOGGER.error(&quot;下载异常：&quot; + e); } finally { try { if (null != out) out.flush(); if (null != out) out.close(); if (null != inputStream) inputStream.close(); } catch (IOException e) { LOGGER.error(&quot;关闭数据流异常：&quot; + e); } } } ","link":"https://fikacode.github.io/post/javaBrokenPointDownload/"},{"title":"java 比较完美的生成验证码的方案","content":" 记得是网上找的，自己改了一下，数字、+ 和等于都是随机的。 package com.km.studio.miJiao.app.noAuthUrl; import java.awt.*; import java.awt.image.BufferedImage; import java.util.HashMap; import java.util.Map; import java.util.Random; public class CreateImageCode { //verification code image width private static final int IMG_WIDTH = 146; //verification code image height private static final int IMG_HEIGHT = 30; //The number of interference lines private static final int DISTURB_LINE_SIZE = 15; //generate a random number private static Random random = new Random(); //result private static int result; //result random string private static String randomString; //Chinese Numbers //Here, must be java Unicode code private static final String CUCUMBERS = &quot;\\u96F6\\u4E00\\u4E8C\\u4E09\\u56DB\\u4E94\\u516D\\u4E03\\u516B\\u4E5D\\u4E58\\u9664\\u52A0\\u51CF&quot;; private static final String NUM_STR = &quot;\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u203b\\u002f\\u002b\\u2796&quot;; //data operator private static final Map&lt;String, Integer&gt; OPMap = new HashMap&lt;&gt;(); static { OPMap.put(&quot;*&quot;, 10); OPMap.put(&quot;/&quot;, 11); OPMap.put(&quot;+&quot;, 12); OPMap.put(&quot;-&quot;, 13); } /** * The generation of image verification code */ public static BufferedImage drawVerificationCodeImage() { //image BufferedImage image = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB); //In memory to create a brush Graphics g = image.getGraphics(); g.setColor(Color.WHITE); g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT); //Set the brush color g.setColor(getRandomColor(200, 250)); //image border g.drawRect(0, 0, IMG_WIDTH - 2, IMG_HEIGHT - 2); //Set disturb line color g.setColor(getRandomColor(110, 133)); //Generate random interference lines for (int i = 0; i &lt; DISTURB_LINE_SIZE; i++) { drawDisturbLine1(g); drawDisturbLine2(g); } //Generate a random number, set return data getRandomMathString(); StringBuilder log = new StringBuilder(); //The generated random string used to save the system for (int j = 0, k = randomString.length(); j &lt; k; j++) { Boolean rd = random(); String t; if (rd) { t = CUCUMBERS; } else { t = NUM_STR; } int child; if (j == 1) { child = OPMap.get(String.valueOf(randomString.charAt(j))); } else { child = Integer.parseInt(String.valueOf(randomString.charAt(j))); } String ch = String.valueOf(t.charAt(child)); log.append(ch); drawRandomString((Graphics2D) g, ch, j); } //= ? if (random()) { drawRandomString((Graphics2D) g, &quot;\\u7B49\\u4E8E\\uFF1F&quot;, 3); log.append(&quot;\\u7B49\\u4E8E\\uFF1F&quot;); } else { drawRandomString((Graphics2D) g, &quot;\\u003d\\uFF1F&quot;, 3); log.append(&quot;\\u003d\\uFF1F&quot;); } //Release the brush object g.dispose(); System.out.println(log.toString()); return image; } private static Boolean random() { int i = new Random().nextInt(2); if (i == 0) { return Boolean.TRUE; } else { return Boolean.FALSE; } } /** * Get a random string */ private static void getRandomMathString() { //Randomly generated number 0 to 10 int xx = random.nextInt(10); int yy = random.nextInt(10); //save getRandomString StringBuilder suChinese = new StringBuilder(); //random 0,1,2 int randomOperands = (int) Math.round(Math.random() * 2); //multiplication if (randomOperands == 0) { result = yy * xx; suChinese.append(yy); suChinese.append(&quot;*&quot;); suChinese.append(xx); //division, divisor cannot be zero, Be divisible } else if (randomOperands == 1) { if (!(xx == 0) &amp;&amp; yy % xx == 0) { result = yy / xx; suChinese.append(yy); suChinese.append(&quot;/&quot;); } else { result = yy + xx; suChinese.append(yy); suChinese.append(&quot;+&quot;); } suChinese.append(xx); //subtraction } else if (randomOperands == 2) { result = yy - xx; suChinese.append(yy); suChinese.append(&quot;-&quot;); suChinese.append(xx); //add } else { result = yy + xx; suChinese.append(yy); suChinese.append(&quot;+&quot;); suChinese.append(xx); } randomString = suChinese.toString(); } private static Font getRandomFont() { int fontSize = (int) Math.round(Math.random() * 4 + 16); return new Font(null, Font.BOLD, fontSize); } /** * Draw a random string * * @param g Graphics * @param i the random number of characters */ private static void drawRandomString(Graphics2D g, String randomVCCH, int i) { //Set the string font style g.setFont(getRandomFont()); int rc = random.nextInt(255); int gc = random.nextInt(255); int bc = random.nextInt(255); g.setColor(new Color(rc, gc, bc)); int x = random.nextInt(3); int y = random.nextInt(2); g.translate(x, y); int degree = new Random().nextInt() % 15; g.rotate(degree * Math.PI / 180, 5 + i * 25, 20); g.drawString(randomVCCH, 5 + i * 25, 20); //Reverse Angle g.rotate(-degree * Math.PI / 180, 5 + i * 25, 20); } /** * Draw line interference * * @param g Graphics */ private static void drawDisturbLine1(Graphics g) { int x1 = random.nextInt(IMG_WIDTH); int y1 = random.nextInt(IMG_HEIGHT); int x2 = random.nextInt(13); int y2 = random.nextInt(15); g.drawLine(x1, y1, x1 + x2, y1 + y2); } /** * Draw line interference * * @param g Graphics */ private static void drawDisturbLine2(Graphics g) { int x1 = random.nextInt(IMG_WIDTH); int y1 = random.nextInt(IMG_HEIGHT); int x2 = random.nextInt(13); int y2 = random.nextInt(15); g.drawLine(x1, y1, x1 - x2, y1 - y2); } /** * For random color * * @param fc fc * @param bc bc * @return color random color */ private static Color getRandomColor(int fc, int bc) { if (fc &gt; 255) { fc = 255; } if (bc &gt; 255) { bc = 255; } //Generate random RGB trichromatic int r = fc + random.nextInt(bc - fc - 16); int g = fc + random.nextInt(bc - fc - 14); int b = fc + random.nextInt(bc - fc - 18); return new Color(r, g, b); } /** * result.&lt;br/&gt; * * @return the result &lt;br/&gt; */ public static int getResult() { return result; } } 使用getResult获取答案，效果图 ","link":"https://fikacode.github.io/post/javaImageCode/"},{"title":"Javascript POST方式下载文件 ","content":"来自网上。 postDownLoadFile: function (options) { var config = $.extend(true, { method: 'post' }, options); var $iframe = $('&lt;iframe id=&quot;admin_self_down-file-iframe&quot; /&gt;'); var $form = $('&lt;form target=&quot;down-file-iframe&quot; method=&quot;' + config.method + '&quot; /&gt;'); $form.attr('action', config.url); for (var key in config.data) { $form.append('&lt;input type=&quot;hidden&quot; name=&quot;' + key + '&quot; value=&quot;' + config.data[key] + '&quot; /&gt;'); } $iframe.append($form); $(document.body).append($iframe); $form[0].submit(); $iframe.remove(); } options 中设置url即可。 ","link":"https://fikacode.github.io/post/javascriptPostDownloadFile/"},{"title":"Mysql 5.7 表名大小写、ONLY_FULL_GROUP_BY和中文UTF-8的设置问题","content":"表名大小写敏感 lower_case_table_names=1 ONLY_FULL_GROUP_BY 问题 sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION' 中文和UTF-8设置 [mysqld] character_set_server=utf8 [client] default-character-set=utf8 以上设置都在配置文件里面修改 ","link":"https://fikacode.github.io/post/mysql57setLowerCaseTableAndSqlModeAndutf8/"},{"title":"Mysql 5.7 root 密码没法设置的问题","content":"问题源于5.7 使用了密码插件，修改root密码可以这样来： 修改插件： update mysql.user set plugin = 'mysql_native_password' where user='root'； flush privileges； 更新密码： update mysql.user set authentication_string=password('new_password') where user='root'； ","link":"https://fikacode.github.io/post/mysql57SetPassword/"},{"title":"SSH 管理多个Key文件","content":"在 ~/.ssh 文件夹下面新建 config，指定key Host xxx.xxx.xxx.xxx HostName xxx.xxx.xxx.xxx PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab User User1 Host xxx.xxx.xxx.xxx HostName xxx.xxx.xxx.xxx PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github User User2 Host 可以是IP或者域名 HostName 同Host IdentityFile 对应的Key私钥 User 私钥对应的用户 ","link":"https://fikacode.github.io/post/sshManageKeys/"},{"title":"Java request 请求转发","content":"使用RestTemplate简单实现。 String body = IOUtils.toString(request.getInputStream(), Charset.forName(request.getCharacterEncoding())); Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); String method = request.getMethod(); try { restTemplate.exchange(url, HttpMethod.valueOf(method), new HttpEntity&lt;&gt;(body), Object.class, parameterMap); } catch (RuntimeException ignored) { } IOUtils是commons-io的包 url是转发的url ","link":"https://fikacode.github.io/post/javaRequestForward/"},{"title":"Spring Boot 在非spring控制的组件获取bean","content":"/** * @ClassName SpringUtil * @Description Spring 工具类 * @Author WFS * @Date 2019/4/3 11:03 **/ @Component public class SpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if (SpringUtil.applicationContext == null) { SpringUtil.applicationContext = applicationContext; } } private static ApplicationContext getApplicationContext() { return applicationContext; } public static Object getBean(String name) { return getApplicationContext().getBean(name); } public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) { return getApplicationContext().getBean(clazz); } public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) { return getApplicationContext().getBean(name, clazz); } } 需要注意几点 SpringUtil需要被Spring Boot 扫描到 使用的时机需要在spring容器加载完所有Bean以后 ","link":"https://fikacode.github.io/post/springbootGetBean/"},{"title":"Spring Security 自定义权限实现 redis token 登陆验证","content":"前言 本文的实现方式主要针于与对spring security有所了解的读者，通过增加filter的方式，替换代替spring security自带的的能登陆逻辑。 准备工作 pom 配置 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- spring security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- JPA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 链接mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jwt --&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 其他的pom配置这里不在贴出，有需要的可自行添加。 redis 配置 RedisTemplate要来读取缓存在redis里面的token，登陆的时候需要使用到。这里为了以后扩展方便，使用RedisStandaloneConfiguration的方式配置RedisTemplate，可以自由配置端口和数据库。 package com.auth.frame.security.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisStandaloneConfiguration; import org.springframework.data.redis.connection.jedis.JedisClientConfiguration; import org.springframework.data.redis.connection.jedis.JedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; /** * @ClassName SecurityRedisConfig * @Author WFS * @Date 2020/1/21 15:56 */ @Configuration public class SecurityRedisConfig { @Bean(&quot;sysTokenRedisTemplate&quot;) public RedisTemplate&lt;String, String&gt; getTokenRedisTemplate() { return buildRedisTemplateByDataBase(10); } private RedisTemplate&lt;String, String&gt; buildRedisTemplateByDataBase(Integer dataBase) { RedisTemplate&lt;String, String&gt; template = new StringRedisTemplate(); RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setHostName(&quot;localhost&quot;); redisStandaloneConfiguration.setPort(6379); redisStandaloneConfiguration.setDatabase(dataBase); JedisClientConfiguration.JedisClientConfigurationBuilder clientConfiguration = JedisClientConfiguration.builder(); clientConfiguration.connectTimeout(Duration.ofSeconds(60)); JedisConnectionFactory codeFactory = new JedisConnectionFactory(redisStandaloneConfiguration, clientConfiguration.build()); template.setConnectionFactory(codeFactory); template.setValueSerializer(new StringRedisSerializer()); template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template; } } 跨域配置 一般使用token的都是前后端分离，跨域这个问题总是要解决。springboot框架自带跨域的filter的配置，但是那个配置有些时候老是会有问题，我建议自己配置filter的方式来增加跨域的支持。 package com.auth.frame.security.processor; import org.springframework.web.bind.annotation.RequestMethod; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @ClassName CROSFilter * @Author WFS * @Date 2020/2/7/0007 16:58 */ public class CORSFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String origin = request.getHeader(&quot;Origin&quot;); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;); response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Authorization&quot;); response.addHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); if (RequestMethod.OPTIONS.toString().equals(request.getMethod())) { servletResponse.getWriter().println(&quot;ok&quot;); return; } filterChain.doFilter(request ,response); } @Override public void init(FilterConfig filterConfig) { } @Override public void destroy() { } } 注册Filter package com.auth.frame.security.config; import com.auth.frame.security.processor.CORSFilter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @ClassName FilterConfig * @Author WFS * @Date 2020/2/7/0007 16:57 */ @Configuration public class FilterConfig { @Bean(name = &quot;CORSFilter&quot;) public FilterRegistrationBean&lt;CORSFilter&gt; setFilter() { FilterRegistrationBean&lt;CORSFilter&gt; filterBean = new FilterRegistrationBean&lt;&gt;(); filterBean.setFilter(new CORSFilter()); filterBean.setOrder(Integer.MIN_VALUE); filterBean.setName(&quot;CORSFilter&quot;); filterBean.addUrlPatterns(&quot;/*&quot;); return filterBean; } } 其余的选项可以按照自己的需求配置filter filterBean.setOrder(Integer.MIN_VALUE); 保证了filter 第一个执行。 原理 token 登陆 spring security是由一大批filter组成，其中UsernamePasswordAuthenticationFilter是用户登陆验证时候的filter，我们要做的就是登陆验证之前检验token，如果token符合我们规则，那么从token里面取出授权信息，然后在SecurityContextHolder里面增加授权信息。这样，后面经过UsernamePasswordAuthenticationFilter时就不会使用自带的登陆验证逻辑检验。如果token不符合规则，直接滤过，UsernamePasswordAuthenticationFilter检验没有授权信息，会引导到登陆页面。 自定义用户权限 自定义用户权限主要用户来配合token做权限判断，从token里面取出来的授权信息就是关联我们的自定义权限。要实现自定义权限我们需要实现三个接口：UserDetailsService，该接口主要获取用户对应的权限；FilterInvocationSecurityMetadataSource启动项目时候所有url的权限信息；AccessDecisionManager投票器，根据用户的权限信息和url权限信息来实现允许或者拒绝的逻辑。 用户信息表 用户表 package com.auth.frame.security.bean; import com.auth.frame.common.BaseEntity; import lombok.*; import javax.persistence.*; import java.util.Set; @EqualsAndHashCode(callSuper = true) @Data @Builder @NoArgsConstructor @AllArgsConstructor @Entity @Table(name = &quot;t_sys_user&quot;, indexes = {@Index(columnList = &quot;id&quot;), @Index(columnList = &quot;phoneNum&quot;)}) public class User extends BaseEntity { @Column(unique = true) private String phoneNum; @Column(unique = true) private String userName; @Column private String salt; @Column private String passWord; @Column private Boolean accountNonExpired; @Column private Boolean accountNonLocked; @Column private Boolean credentialsNonExpired; @Column private Boolean enabled; @ManyToMany(fetch = FetchType.EAGER) @JoinTable(name = &quot;t_sys_user_role&quot;, joinColumns = {@JoinColumn(name = &quot;user_id&quot;, referencedColumnName = &quot;id&quot;)} , inverseJoinColumns = {@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)}) private Set&lt;Role&gt; roles; } 角色表 package com.auth.frame.security.bean; import com.auth.frame.common.BaseEntity; import lombok.*; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.Index; import javax.persistence.Table; @EqualsAndHashCode(callSuper = true) @Data @Builder @NoArgsConstructor @AllArgsConstructor @Entity @Table(name = &quot;t_sys_role&quot;, indexes = {@Index(columnList = &quot;id&quot;)}) public class Role extends BaseEntity { @Column private String name; @Column private String auth; } URL表 package com.auth.frame.security.bean; import com.auth.frame.common.BaseEntity; import lombok.*; import javax.persistence.*; import java.util.Set; @EqualsAndHashCode(callSuper = true) @Data @Builder @NoArgsConstructor @AllArgsConstructor @Entity @Table(name = &quot;t_sys_url&quot;, indexes = {@Index(columnList = &quot;id&quot;)}) public class URL extends BaseEntity { @Column private String name; @Column private String path; @ManyToMany (fetch = FetchType.EAGER) @JoinTable(name = &quot;t_sys_url_role&quot;, joinColumns = {@JoinColumn(name = &quot;url_id&quot;, referencedColumnName = &quot;id&quot;)} , inverseJoinColumns = {@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)}) private Set&lt;Role&gt; roles; } BaseEntity 主要是提供主键和创建、修改时间的字段。 注解中使用了 lombok。 角色、用户和URL使用的是单边对应，如有需要可改为多边对应。 自定义认证 UserDetails UserDetails是spring security中的用户信息接口，通过实现UserDetails可以和User表关联起来。 package com.auth.frame.security.processor; import com.auth.frame.security.bean.User; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import java.util.Collection; /** * @ClassName CSTUserDetailService * @Author WFS * @Date 2020/1/21 10:39 */ @NoArgsConstructor @AllArgsConstructor @Data public class CSTUserDetails implements UserDetails { private Collection&lt;SimpleGrantedAuthority&gt; authorities; private String username; private String userId; private Boolean accountNonExpired; private Boolean accountNonLocked; private Boolean credentialsNonExpired; private Boolean enabled; public CSTUserDetails(Collection&lt;SimpleGrantedAuthority&gt; authorities, String username, String userId, boolean accountNonExpired, boolean accountNonLocked, boolean credentialsNonExpired, boolean enabled) { this.authorities = authorities; this.username = username; this.userId = userId; this.accountNonExpired = accountNonExpired; this.accountNonLocked = accountNonLocked; this.credentialsNonExpired = credentialsNonExpired; this.enabled = enabled; } public CSTUserDetails(User user) { this.authorities = CSTUserDetailsService.getAuthorities(user); this.username = user.getUserName(); this.userId = user.getId(); this.accountNonExpired = user.getAccountNonExpired(); this.accountNonLocked = user.getAccountNonLocked(); this.credentialsNonExpired = user.getCredentialsNonExpired(); this.enabled = user.getEnabled(); } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return authorities; } @Override public String getPassword() { return null; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return accountNonExpired; } @Override public boolean isAccountNonLocked() { return accountNonLocked; } @Override public boolean isCredentialsNonExpired() { return credentialsNonExpired; } @Override public boolean isEnabled() { return enabled; } } authorities是用户对应的权限，其实就是一个字符串列表，可以自行拓展。 UserDetailsService UserDetailsService接口规定了通过用户名获取用户信息的接口，即获取UserDetails。 package com.auth.frame.security.processor; import com.auth.frame.security.bean.Role; import com.auth.frame.security.bean.User; import com.auth.frame.security.service.UserService; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Component; import java.util.Collection; import java.util.HashSet; import java.util.Set; /** * @ClassName CSTUserDetailsService * @Author WFS * @Date 2020/1/21 10:50 */ @Component public class CSTUserDetailsService implements UserDetailsService { private final UserService userService; public CSTUserDetailsService(UserService userService) { this.userService = userService; } @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { User user = userService.getCacheUser(s); if (user == null) { throw new UsernameNotFoundException(&quot;User Not Find!&quot;); } else { Collection&lt;SimpleGrantedAuthority&gt; authorities = getAuthorities(user); return new CSTUserDetails(authorities, user.getUserName(), user.getId(), user.getAccountNonExpired(), user.getAccountNonLocked(), user.getCredentialsNonExpired(), user.getEnabled()); } } public static Collection&lt;SimpleGrantedAuthority&gt; getAuthorities(User user) { Set&lt;Role&gt; roleSet = user.getRoles(); Collection&lt;SimpleGrantedAuthority&gt; authorities = new HashSet&lt;&gt;(); if (roleSet != null &amp;&amp; !roleSet.isEmpty()) { roleSet.forEach(role -&gt; authorities.add(new SimpleGrantedAuthority(role.getAuth()))); } return authorities; } } loadUserByUsername函数中的参数s即为用户名，userService.getCacheUser的作用是根据用户名获取用户，此处使用的自己写的从缓存获取用户名，可以自由发挥，只要能构建UserDetails即可。 FilterInvocationSecurityMetadataSource FilterInvocationSecurityMetadataSource元数据，接口获取的是全部URL的权限信息和当http请求过来时候url对应的权限。其中getAttributes的参数o包含了当前访问的URL，根据URL我们需要返回对应的权限信息；getAllConfigAttributes会在项目启动时执行一次，获取所有URL对应的权限信息。 package com.auth.frame.security.processor; import com.auth.frame.security.bean.Role; import com.auth.frame.security.repository.RoleRepository; import com.auth.frame.security.service.URLService; import org.springframework.security.access.ConfigAttribute; import org.springframework.security.access.SecurityConfig; import org.springframework.security.web.FilterInvocation; import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource; import java.util.Collection; import java.util.HashSet; import java.util.Set; import static com.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE; /** * @ClassName CSTSecurityMetadataSource * @Author WFS * @Date 2020/1/21 17:06 */ public class CSTSecurityMetadataSource implements FilterInvocationSecurityMetadataSource { private URLService urlService; private RoleRepository roleRepository; public CSTSecurityMetadataSource(URLService urlService, RoleRepository roleRepository) { this.urlService = urlService; this.roleRepository = roleRepository; } @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException { String url = ((FilterInvocation) o).getRequestUrl(); Collection&lt;ConfigAttribute&gt; configAttributes = new HashSet&lt;&gt;(); Set&lt;Role&gt; roles = urlService.getCacheURL(url); roles.forEach(ele -&gt; configAttributes.add(new SecurityConfig(ele.getAuth()))); if (configAttributes.isEmpty()) { configAttributes.add(new SecurityConfig(DEFAULT_ROLE)); } return configAttributes; } @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() { Collection&lt;ConfigAttribute&gt; configAttributes = new HashSet&lt;&gt;(); roleRepository.findAllByDeletedIsFalse().forEach(e -&gt; configAttributes.add(new SecurityConfig(e.getAuth()))); return configAttributes; } @Override public boolean supports(Class&lt;?&gt; aClass) { return true; } } AccessDecisionManager 投票管理器，接口规定了用户权限和URL权限之间的逻辑，即满足某种情况拒绝或者允许。 package com.auth.frame.security.processor; import org.springframework.security.access.AccessDecisionManager; import org.springframework.security.access.AccessDeniedException; import org.springframework.security.access.ConfigAttribute; import org.springframework.security.authentication.InsufficientAuthenticationException; import org.springframework.security.core.Authentication; import java.util.Collection; import static com.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE; /** * @ClassName CSTAccessDecisionManager * @Author WFS * @Date 2020/1/21 17:06 */ public class CSTAccessDecisionManager implements AccessDecisionManager { @Override public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException { if (collection.size() == 1 &amp;&amp; collection.stream().anyMatch(ele -&gt; DEFAULT_ROLE.equals(ele.getAttribute()))) { return; } if (!collection.stream().allMatch(ele -&gt; authentication.getAuthorities().stream().anyMatch(e -&gt; ele.getAttribute().equals(e.getAuthority())))) { throw new AccessDeniedException(&quot;AccessDenied!&quot;); } } @Override public boolean supports(ConfigAttribute configAttribute) { return Boolean.TRUE; } @Override public boolean supports(Class&lt;?&gt; aClass) { return Boolean.TRUE; } } Authentication中包含有用户的权限信息，Collection&lt;ConfigAttribute&gt;包含有当前URL需要的权限信息，根据这两个参数我们就可以自由的指定我们投票规则。比如：某个URL含有多个权限，某个用户只要拥有其中一个就可以访问，或者要求必须全部拥有对应的权限才可以访问，此处可以自由发挥。需要注意的是，AccessDecisionManager不起作用的情况，原因是如果Collection&lt;ConfigAttribute&gt;为null或者empty，则不会执行投票器，所以我们需要给没有配置权限的URL一个默认权限。 tokenFilter tokenFilter主要用来检查是否登陆的逻辑。先从请求里面获取token，解密，然后从reids里面获取相关权限信息；如果没有token则检查是否是用户名和密码，如果存在那么验证用户名和密码是否匹配，然后生成授权信息，存入redis，返回token给前端。 package com.auth.frame.security.processor; import com.auth.frame.common.ResponseEntity; import com.auth.frame.common.Utils.JSONUtil; import com.auth.frame.common.Utils.StringUtil; import com.auth.frame.security.Utils.TokenUtil; import com.auth.frame.security.bean.User; import com.auth.frame.security.repository.UserRepository; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.stereotype.Component; import org.springframework.util.DigestUtils; import javax.annotation.Resource; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.Set; import java.util.UUID; import java.util.concurrent.TimeUnit; /** * @ClassName TokenFilter * @Author WFS * @Date 2020/1/21 10:47 */ @Component public class TokenFilter implements Filter { private final UserRepository userRepository; @Resource(name = &quot;sysTokenRedisTemplate&quot;) public RedisTemplate&lt;String, String&gt; redisTemplate; private static final String usernameParameter = &quot;username&quot;; private static final String passwordParameter = &quot;password&quot;; public TokenFilter(UserRepository userRepository) { this.userRepository = userRepository; } @Override public void init(FilterConfig filterConfig) { } @Override public void destroy() { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String rds = TokenUtil.getBody(request); if (rds == null) { String username = request.getParameter(usernameParameter); String password = request.getParameter(passwordParameter); if (!StringUtil.isNullOrEmpty(username, password)) { User user = userRepository.findByDeletedIsFalseAndUserName(username); if (user != null) { if (user.getAccountNonExpired() &amp;&amp; user.getAccountNonLocked() &amp;&amp; user.getCredentialsNonExpired() &amp;&amp; user.getEnabled()) { if (!StringUtil.isNullOrEmpty(user.getSalt(), user.getPassWord())) { if (user.getPassWord().equals(DigestUtils.md5DigestAsHex((password + user.getSalt()).getBytes(StandardCharsets.UTF_8)))) { Set&lt;String&gt; rdsSet = redisTemplate.keys(&quot;*&quot;); if (rdsSet != null) { for (String s : rdsSet) { String rc = redisTemplate.opsForValue().get(s); if (rc != null) { CSTUserDetails rc_u = JSONUtil.json2Obj(rc, CSTUserDetails.class); if (rc_u != null) { if (user.getId().equals(rc_u.getUserId())) { redisTemplate.delete(s); } } } } } CSTUserDetails cstUserDetails = new CSTUserDetails(user); String r = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); redisTemplate.opsForValue().set(r, JSONUtil.obj2Json(cstUserDetails)); redisTemplate.expire(r, 2, TimeUnit.HOURS); String token = TokenUtil.create(r); ResponseEntity.ofToken(response, token); return; } } } } } } else { String cuStr = redisTemplate.opsForValue().get(rds); if (!StringUtil.isNullOrEmpty(cuStr)) { CSTUserDetails cu = JSONUtil.json2Obj(cuStr, CSTUserDetails.class); if (cu != null) { if (cu.getAccountNonExpired() &amp;&amp; cu.getAccountNonLocked() &amp;&amp; cu.getCredentialsNonExpired() &amp;&amp; cu.getEnabled()) { SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(cu.getUserId(), cu.getPassword(), cu.getAuthorities())); } } } } filterChain.doFilter(servletRequest, servletResponse); } } TokenUtil 主要从request里面解析token里面的rds 中间有一段redis的操作，此处可以自行拓展，即每一个新的附带密码的请求都去删除redis里面相同userId的授权信息，这样做的好处是可以保证每个账号同一个时间只有一个人登陆。 ResponseEntity.ofToken() 工具类，用于向response返回信息 配置spring security 设置withObjectPostProcessor来设置AccessDecisionManager和SecurityMetadataSource，addFilterBefore设置TokenFilter的位置，web.ignoring设置开放API的路径，开放API不受spring security过滤链的控制。 package com.auth.frame.security.config; import com.auth.frame.security.processor.CSTAccessDecisionManager; import com.auth.frame.security.processor.CSTSecurityMetadataSource; import com.auth.frame.security.processor.CSTUserDetailsService; import com.auth.frame.security.processor.TokenFilter; import com.auth.frame.security.repository.RoleRepository; import com.auth.frame.security.service.URLService; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.ObjectPostProcessor; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.builders.WebSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.web.access.intercept.FilterSecurityInterceptor; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.web.cors.CorsUtils; /** * @ClassName SecurityConfig * @Author WFS * @Date 2020/1/21 10:25 */ @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(jsr250Enabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { private final CSTUserDetailsService cstUserDetailsService; private final ApplicationSecurityConfig applicationSecurityConfig; private final TokenFilter tokenFilter; private final URLService urlService; private final RoleRepository roleRepository; public SecurityConfig(CSTUserDetailsService cstUserDetailsService, ApplicationSecurityConfig applicationSecurityConfig, TokenFilter tokenFilter, URLService urlService, RoleRepository roleRepository) { this.cstUserDetailsService = cstUserDetailsService; this.applicationSecurityConfig = applicationSecurityConfig; this.tokenFilter = tokenFilter; this.urlService = urlService; this.roleRepository = roleRepository; } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(cstUserDetailsService); } @Bean public CSTAccessDecisionManager getCSTAccessDecisionManager() { return new CSTAccessDecisionManager(); } @Bean public CSTSecurityMetadataSource getCSTSecurityMetadataSource() { return new CSTSecurityMetadataSource(urlService, roleRepository); } @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable().cors() .and().authorizeRequests() .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) { o.setAccessDecisionManager(getCSTAccessDecisionManager()); o.setSecurityMetadataSource(getCSTSecurityMetadataSource()); return o; } }) .requestMatchers(CorsUtils::isPreFlightRequest).permitAll() .anyRequest().authenticated() .and().anonymous().disable().formLogin().permitAll() .and().addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class) .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); } @Override public void configure(WebSecurity web) { web.ignoring().regexMatchers(applicationSecurityConfig.getOpenApi()); } } 结语 通过以上逻辑，token登陆和自定义权限功能已经完成，其实所有的功能实现集中于UserDetails的构建和AccessDecisionManager投票逻辑，熟知于此就可以随意拓展Filter来实现自己的功能。 ","link":"https://fikacode.github.io/post/springSecurityTokenLogin/"},{"title":"excel强制启用VBA","content":"事实上VBA的启用依赖于运行的容器，VBA本身没有强制启用的功能。但是我们可以用另外一种方法来实现 强制启用的功能：如果不启用那么，显示一个页面，提示启用；如果启用就隐藏提示，显示正文。 大概代码如下： Private Sub Workbook_BeforeClose(Cancel As Boolean) Dim sh AsWorksheet ForEach sht In Worksheets If sht.Name&lt;&gt;”Welcome”Then Sheets(sht.Name).Visible= False End If Next Sheets(“Welcome”).Visible= True Sheets(“Welcome”).Select ThisWorkbook.Save End Sub Private Sub Workbook_Open() Dim sht AsWorksheet ForEach sht In Worksheets If sht.Name&lt;&gt;”Welcome” Then sht.Visible = xlSheetVisible End If Next Worksheets(“Welcome”).Visible= xlSheetVeryHidden ThisWorkbook.Save End Sub 代码很好理解：关闭之前，隐藏所有sheet，只显示Welcome；打开文件隐藏Welcome，显示正文。 ","link":"https://fikacode.github.io/post/excelForceEnableVba/"},{"title":"spring boot 打包为外置 tomcat (war)","content":"修改pom文件 &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 移除嵌入式tomcat插件 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 修改Application启动类 修改前 public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 修改后 public class Application extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(Application.class); } public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 特别注意 如果使用了 websocket，那么需要注释掉下面的代码，同时添加websocket的支持。 @Configuration public class WebSocketConfig { // @Bean // public ServerEndpointExporter serverEndpointExporter() { // return new ServerEndpointExporter(); // } } &lt;!-- https://mvnrepository.com/artifact/javax.websocket/javax.websocket-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 如果使用了注解@WebFilter，那么需要使用FilterRegistrationBean的方式来注册Filter。 ","link":"https://fikacode.github.io/post/springbootPackageToWar/"},{"title":"tomcat 常用的优化","content":"catalina 设置 java 参数 set CATALINA_OPTS=-Dfile.encoding=UTF-8 -server -Xms8192m -Xmx8192m -Xmn4096m -XX:SurvivorRatio=10 -XX:MaxTenuringThreshold=15 -XX:NewRatio=2 -XX:+DisableExplicitGC 根据环境的配置优化相关参数 Server.xml 设置连接池 &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; maxThreads=&quot;500&quot; minSpareThreads=&quot;100&quot; prestartminSpareThreads = &quot;true&quot; maxQueueSize = &quot;100&quot; /&gt; 开启压缩和 NIO2 &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;80&quot; protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot; connectionTimeout=&quot;20000&quot; maxConnections=&quot;10000&quot; redirectPort=&quot;8443&quot; enableLookups=&quot;false&quot; acceptCount=&quot;100&quot; maxPostSize=&quot;10485760&quot; compression=&quot;on&quot; disableUploadTimeout=&quot;true&quot; compressionMinSize=&quot;50&quot; acceptorThreadCount=&quot;4&quot; compressableMimeType=&quot;text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/x-javascript,application/json,image/jpg,application/x-font-ttf,application/x-font-otf,image/svg+xml,image/jpeg,image/png,image/gif,audio/mpeg,video/mp4,font/woff&quot; URIEncoding=&quot;utf-8&quot; /&gt; web.xml 设置缓存 &lt;filter&gt; &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.ExpiresFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;ExpiresByType image&lt;/param-name&gt; &lt;param-value&gt;access plus 30 days&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ExpiresByType text&lt;/param-name&gt; &lt;param-value&gt;access plus 30 days&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ExpiresByType application/javascript&lt;/param-name&gt; &lt;param-value&gt;access plus 30 days&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ExpiresByType multipart/form-data&lt;/param-name&gt; &lt;param-value&gt;access plus 30 days&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ExpiresByType font/woff&lt;/param-name&gt; &lt;param-value&gt;access plus 30 days&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;/filter-mapping&gt; ","link":"https://fikacode.github.io/post/tomcatOptimizationAndCache/"},{"title":"java 将数组均分为多个数组","content":"将一组数据平均分成n组 /** * 将一组数据平均分成n组 * * @param source 要分组的数据源 * @param n 平均分成n组 * @param &lt;T&gt; * @return */ public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; averageAssign(List&lt;T&gt; source, int n) { List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;(); int remainder = source.size() % n; //(先计算出余数) int number = source.size() / n; //然后是商 int offset = 0;//偏移量 for (int i = 0; i &lt; n; i++) { List&lt;T&gt; value = null; if (remainder &gt; 0) { value = source.subList(i * number + offset, (i + 1) * number + offset + 1); remainder--; offset++; } else { value = source.subList(i * number + offset, (i + 1) * number + offset); } result.add(value); } return result; } 将一组数据固定分组，每组n个元素 /** * 将一组数据固定分组，每组n个元素 * @param source 要分组的数据源 * @param n 每组n个元素 * @param &lt;T&gt; * @return */ public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; fixedGrouping(List&lt;T&gt; source, int n) { if (null == source || source.size() == 0 || n &lt;= 0) return null; List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;(); int sourceSize = source.size(); int size = (source.size() / n) + 1; for (int i = 0; i &lt; size; i++) { List&lt;T&gt; subset = new ArrayList&lt;T&gt;(); for (int j = i * n; j &lt; (i + 1) * n; j++) { if (j &lt; sourceSize) { subset.add(source.get(j)); } } result.add(subset); } return result; } 将一组数据固定分组，每组n个元素 /** * 将一组数据固定分组，每组n个元素，第二种写法 * * @param source 要分组的数据源 * @param n 每组n个元素 * @param &lt;T&gt; * @return */ public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; fixedGrouping2(List&lt;T&gt; source, int n) { if (null == source || source.size() == 0 || n &lt;= 0) return null; List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;(); int remainder = source.size() % n; int size = (source.size() / n); for (int i = 0; i &lt; size; i++) { List&lt;T&gt; subset = null; subset = source.subList(i * n, (i + 1) * n); result.add(subset); } if (remainder &gt; 0) { List&lt;T&gt; subset = null; subset = source.subList(size * n, size * n + remainder); result.add(subset); } return result; } ","link":"https://fikacode.github.io/post/javaListAverage/"}]}