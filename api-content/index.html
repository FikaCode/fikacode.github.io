{"posts":[{"title":"Spring Boot 在非spring控制的组件获取bean","content":"/***@ClassNameSpringUtil*@DescriptionSpring工具类*@AuthorWFS*@Date2019/4/311:03**/@ComponentpublicclassSpringUtilimplementsApplicationContextAware{privatestaticApplicationContextapplicationContext;@OverridepublicvoidsetApplicationContext(ApplicationContextapplicationContext)throwsBeansException{if(SpringUtil.applicationContext==null){SpringUtil.applicationContext=applicationContext;}}privatestaticApplicationContextgetApplicationContext(){returnapplicationContext;}publicstaticObjectgetBean(Stringname){returngetApplicationContext().getBean(name);}publicstatic&lt;T&gt;TgetBean(Class&lt;T&gt;clazz){returngetApplicationContext().getBean(clazz);}publicstatic&lt;T&gt;TgetBean(Stringname,Class&lt;T&gt;clazz){returngetApplicationContext().getBean(name,clazz);}}需要注意几点SpringUtil需要被SpringBoot扫描到使用的时机需要在spring容器加载完所有Bean以后","link":"https://fikacode.github.io/post/springbootGetBean/"},{"title":"Spring Security 自定义权限实现 redis token 登陆验证","content":"前言本文的实现方式主要针于与对springsecurity有所了解的读者，通过增加filter的方式，替换代替springsecurity自带的的能登陆逻辑。准备工作pom配置&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;&lt;!--springsecurity--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--redis--&gt;&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;/groupId&gt;&lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--redis--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--JPA--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--链接mysql--&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--jwt--&gt;&lt;dependency&gt;&lt;groupId&gt;com.auth0&lt;/groupId&gt;&lt;artifactId&gt;java-jwt&lt;/artifactId&gt;&lt;version&gt;3.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;其他的pom配置这里不在贴出，有需要的可自行添加。redis配置RedisTemplate要来读取缓存在redis里面的token，登陆的时候需要使用到。这里为了以后扩展方便，使用RedisStandaloneConfiguration的方式配置RedisTemplate，可以自由配置端口和数据库。packagecom.auth.frame.security.config;importorg.springframework.context.annotation.Bean;importorg.springframework.context.annotation.Configuration;importorg.springframework.data.redis.connection.RedisStandaloneConfiguration;importorg.springframework.data.redis.connection.jedis.JedisClientConfiguration;importorg.springframework.data.redis.connection.jedis.JedisConnectionFactory;importorg.springframework.data.redis.core.RedisTemplate;importorg.springframework.data.redis.core.StringRedisTemplate;importorg.springframework.data.redis.serializer.StringRedisSerializer;importjava.time.Duration;/***@ClassNameSecurityRedisConfig*@AuthorWFS*@Date2020/1/2115:56*/@ConfigurationpublicclassSecurityRedisConfig{@Bean(&quot;sysTokenRedisTemplate&quot;)publicRedisTemplate&lt;String,String&gt;getTokenRedisTemplate(){returnbuildRedisTemplateByDataBase(10);}privateRedisTemplate&lt;String,String&gt;buildRedisTemplateByDataBase(IntegerdataBase){RedisTemplate&lt;String,String&gt;template=newStringRedisTemplate();RedisStandaloneConfigurationredisStandaloneConfiguration=newRedisStandaloneConfiguration();redisStandaloneConfiguration.setHostName(&quot;localhost&quot;);redisStandaloneConfiguration.setPort(6379);redisStandaloneConfiguration.setDatabase(dataBase);JedisClientConfiguration.JedisClientConfigurationBuilderclientConfiguration=JedisClientConfiguration.builder();clientConfiguration.connectTimeout(Duration.ofSeconds(60));JedisConnectionFactorycodeFactory=newJedisConnectionFactory(redisStandaloneConfiguration,clientConfiguration.build());template.setConnectionFactory(codeFactory);template.setValueSerializer(newStringRedisSerializer());template.setKeySerializer(newStringRedisSerializer());template.setHashKeySerializer(newStringRedisSerializer());template.setHashValueSerializer(newStringRedisSerializer());template.afterPropertiesSet();returntemplate;}}跨域配置一般使用token的都是前后端分离，跨域这个问题总是要解决。springboot框架自带跨域的filter的配置，但是那个配置有些时候老是会有问题，我建议自己配置filter的方式来增加跨域的支持。packagecom.auth.frame.security.processor;importorg.springframework.web.bind.annotation.RequestMethod;importjavax.servlet.*;importjavax.servlet.http.HttpServletRequest;importjavax.servlet.http.HttpServletResponse;importjava.io.IOException;/***@ClassNameCROSFilter*@AuthorWFS*@Date2020/2/7/000716:58*/publicclassCORSFilterimplementsFilter{@OverridepublicvoiddoFilter(ServletRequestservletRequest,ServletResponseservletResponse,FilterChainfilterChain)throwsIOException,ServletException{HttpServletRequestrequest=(HttpServletRequest)servletRequest;HttpServletResponseresponse=(HttpServletResponse)servletResponse;Stringorigin=request.getHeader(&quot;Origin&quot;);response.setHeader(&quot;Access-Control-Allow-Origin&quot;,origin);response.addHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;GET,POST,PUT,DELETE,OPTIONS&quot;);response.addHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;Content-Type,Authorization&quot;);response.addHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;);if(RequestMethod.OPTIONS.toString().equals(request.getMethod())){servletResponse.getWriter().println(&quot;ok&quot;);return;}filterChain.doFilter(request,response);}@Overridepublicvoidinit(FilterConfigfilterConfig){}@Overridepublicvoiddestroy(){}}注册Filterpackagecom.auth.frame.security.config;importcom.auth.frame.security.processor.CORSFilter;importorg.springframework.boot.web.servlet.FilterRegistrationBean;importorg.springframework.context.annotation.Bean;importorg.springframework.context.annotation.Configuration;/***@ClassNameFilterConfig*@AuthorWFS*@Date2020/2/7/000716:57*/@ConfigurationpublicclassFilterConfig{@Bean(name=&quot;CORSFilter&quot;)publicFilterRegistrationBean&lt;CORSFilter&gt;setFilter(){FilterRegistrationBean&lt;CORSFilter&gt;filterBean=newFilterRegistrationBean&lt;&gt;();filterBean.setFilter(newCORSFilter());filterBean.setOrder(Integer.MIN_VALUE);filterBean.setName(&quot;CORSFilter&quot;);filterBean.addUrlPatterns(&quot;/*&quot;);returnfilterBean;}}其余的选项可以按照自己的需求配置filterfilterBean.setOrder(Integer.MIN_VALUE);保证了filter第一个执行。原理token登陆springsecurity是由一大批filter组成，其中UsernamePasswordAuthenticationFilter是用户登陆验证时候的filter，我们要做的就是登陆验证之前检验token，如果token符合我们规则，那么从token里面取出授权信息，然后在SecurityContextHolder里面增加授权信息。这样，后面经过UsernamePasswordAuthenticationFilter时就不会使用自带的登陆验证逻辑检验。如果token不符合规则，直接滤过，UsernamePasswordAuthenticationFilter检验没有授权信息，会引导到登陆页面。自定义用户权限自定义用户权限主要用户来配合token做权限判断，从token里面取出来的授权信息就是关联我们的自定义权限。要实现自定义权限我们需要实现三个接口：UserDetailsService，该接口主要获取用户对应的权限；FilterInvocationSecurityMetadataSource启动项目时候所有url的权限信息；AccessDecisionManager投票器，根据用户的权限信息和url权限信息来实现允许或者拒绝的逻辑。用户信息表用户表packagecom.auth.frame.security.bean;importcom.auth.frame.common.BaseEntity;importlombok.*;importjavax.persistence.*;importjava.util.Set;@EqualsAndHashCode(callSuper=true)@Data@Builder@NoArgsConstructor@AllArgsConstructor@Entity@Table(name=&quot;t_sys_user&quot;,indexes={@Index(columnList=&quot;id&quot;),@Index(columnList=&quot;phoneNum&quot;)})publicclassUserextendsBaseEntity{@Column(unique=true)privateStringphoneNum;@Column(unique=true)privateStringuserName;@ColumnprivateStringsalt;@ColumnprivateStringpassWord;@ColumnprivateBooleanaccountNonExpired;@ColumnprivateBooleanaccountNonLocked;@ColumnprivateBooleancredentialsNonExpired;@ColumnprivateBooleanenabled;@ManyToMany(fetch=FetchType.EAGER)@JoinTable(name=&quot;t_sys_user_role&quot;,joinColumns={@JoinColumn(name=&quot;user_id&quot;,referencedColumnName=&quot;id&quot;)},inverseJoinColumns={@JoinColumn(name=&quot;role_id&quot;,referencedColumnName=&quot;id&quot;)})privateSet&lt;Role&gt;roles;}角色表packagecom.auth.frame.security.bean;importcom.auth.frame.common.BaseEntity;importlombok.*;importjavax.persistence.Column;importjavax.persistence.Entity;importjavax.persistence.Index;importjavax.persistence.Table;@EqualsAndHashCode(callSuper=true)@Data@Builder@NoArgsConstructor@AllArgsConstructor@Entity@Table(name=&quot;t_sys_role&quot;,indexes={@Index(columnList=&quot;id&quot;)})publicclassRoleextendsBaseEntity{@ColumnprivateStringname;@ColumnprivateStringauth;}URL表packagecom.auth.frame.security.bean;importcom.auth.frame.common.BaseEntity;importlombok.*;importjavax.persistence.*;importjava.util.Set;@EqualsAndHashCode(callSuper=true)@Data@Builder@NoArgsConstructor@AllArgsConstructor@Entity@Table(name=&quot;t_sys_url&quot;,indexes={@Index(columnList=&quot;id&quot;)})publicclassURLextendsBaseEntity{@ColumnprivateStringname;@ColumnprivateStringpath;@ManyToMany(fetch=FetchType.EAGER)@JoinTable(name=&quot;t_sys_url_role&quot;,joinColumns={@JoinColumn(name=&quot;url_id&quot;,referencedColumnName=&quot;id&quot;)},inverseJoinColumns={@JoinColumn(name=&quot;role_id&quot;,referencedColumnName=&quot;id&quot;)})privateSet&lt;Role&gt;roles;}BaseEntity主要是提供主键和创建、修改时间的字段。注解中使用了lombok。角色、用户和URL使用的是单边对应，如有需要可改为多边对应。自定义认证UserDetailsUserDetails是springsecurity中的用户信息接口，通过实现UserDetails可以和User表关联起来。packagecom.auth.frame.security.processor;importcom.auth.frame.security.bean.User;importlombok.AllArgsConstructor;importlombok.Data;importlombok.NoArgsConstructor;importorg.springframework.security.core.GrantedAuthority;importorg.springframework.security.core.authority.SimpleGrantedAuthority;importorg.springframework.security.core.userdetails.UserDetails;importjava.util.Collection;/***@ClassNameCSTUserDetailService*@AuthorWFS*@Date2020/1/2110:39*/@NoArgsConstructor@AllArgsConstructor@DatapublicclassCSTUserDetailsimplementsUserDetails{privateCollection&lt;SimpleGrantedAuthority&gt;authorities;privateStringusername;privateStringuserId;privateBooleanaccountNonExpired;privateBooleanaccountNonLocked;privateBooleancredentialsNonExpired;privateBooleanenabled;publicCSTUserDetails(Collection&lt;SimpleGrantedAuthority&gt;authorities,Stringusername,StringuserId,booleanaccountNonExpired,booleanaccountNonLocked,booleancredentialsNonExpired,booleanenabled){this.authorities=authorities;this.username=username;this.userId=userId;this.accountNonExpired=accountNonExpired;this.accountNonLocked=accountNonLocked;this.credentialsNonExpired=credentialsNonExpired;this.enabled=enabled;}publicCSTUserDetails(Useruser){this.authorities=CSTUserDetailsService.getAuthorities(user);this.username=user.getUserName();this.userId=user.getId();this.accountNonExpired=user.getAccountNonExpired();this.accountNonLocked=user.getAccountNonLocked();this.credentialsNonExpired=user.getCredentialsNonExpired();this.enabled=user.getEnabled();}@OverridepublicCollection&lt;?extendsGrantedAuthority&gt;getAuthorities(){returnauthorities;}@OverridepublicStringgetPassword(){returnnull;}@OverridepublicStringgetUsername(){returnusername;}@OverridepublicbooleanisAccountNonExpired(){returnaccountNonExpired;}@OverridepublicbooleanisAccountNonLocked(){returnaccountNonLocked;}@OverridepublicbooleanisCredentialsNonExpired(){returncredentialsNonExpired;}@OverridepublicbooleanisEnabled(){returnenabled;}}authorities是用户对应的权限，其实就是一个字符串列表，可以自行拓展。UserDetailsServiceUserDetailsService接口规定了通过用户名获取用户信息的接口，即获取UserDetails。packagecom.auth.frame.security.processor;importcom.auth.frame.security.bean.Role;importcom.auth.frame.security.bean.User;importcom.auth.frame.security.service.UserService;importorg.springframework.security.core.authority.SimpleGrantedAuthority;importorg.springframework.security.core.userdetails.UserDetails;importorg.springframework.security.core.userdetails.UserDetailsService;importorg.springframework.security.core.userdetails.UsernameNotFoundException;importorg.springframework.stereotype.Component;importjava.util.Collection;importjava.util.HashSet;importjava.util.Set;/***@ClassNameCSTUserDetailsService*@AuthorWFS*@Date2020/1/2110:50*/@ComponentpublicclassCSTUserDetailsServiceimplementsUserDetailsService{privatefinalUserServiceuserService;publicCSTUserDetailsService(UserServiceuserService){this.userService=userService;}@OverridepublicUserDetailsloadUserByUsername(Strings)throwsUsernameNotFoundException{Useruser=userService.getCacheUser(s);if(user==null){thrownewUsernameNotFoundException(&quot;UserNotFind!&quot;);}else{Collection&lt;SimpleGrantedAuthority&gt;authorities=getAuthorities(user);returnnewCSTUserDetails(authorities,user.getUserName(),user.getId(),user.getAccountNonExpired(),user.getAccountNonLocked(),user.getCredentialsNonExpired(),user.getEnabled());}}publicstaticCollection&lt;SimpleGrantedAuthority&gt;getAuthorities(Useruser){Set&lt;Role&gt;roleSet=user.getRoles();Collection&lt;SimpleGrantedAuthority&gt;authorities=newHashSet&lt;&gt;();if(roleSet!=null&amp;&amp;!roleSet.isEmpty()){roleSet.forEach(role-&gt;authorities.add(newSimpleGrantedAuthority(role.getAuth())));}returnauthorities;}}loadUserByUsername函数中的参数s即为用户名，userService.getCacheUser的作用是根据用户名获取用户，此处使用的自己写的从缓存获取用户名，可以自由发挥，只要能构建UserDetails即可。FilterInvocationSecurityMetadataSourceFilterInvocationSecurityMetadataSource元数据，接口获取的是全部URL的权限信息和当http请求过来时候url对应的权限。其中getAttributes的参数o包含了当前访问的URL，根据URL我们需要返回对应的权限信息；getAllConfigAttributes会在项目启动时执行一次，获取所有URL对应的权限信息。packagecom.auth.frame.security.processor;importcom.auth.frame.security.bean.Role;importcom.auth.frame.security.repository.RoleRepository;importcom.auth.frame.security.service.URLService;importorg.springframework.security.access.ConfigAttribute;importorg.springframework.security.access.SecurityConfig;importorg.springframework.security.web.FilterInvocation;importorg.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;importjava.util.Collection;importjava.util.HashSet;importjava.util.Set;importstaticcom.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE;/***@ClassNameCSTSecurityMetadataSource*@AuthorWFS*@Date2020/1/2117:06*/publicclassCSTSecurityMetadataSourceimplementsFilterInvocationSecurityMetadataSource{privateURLServiceurlService;privateRoleRepositoryroleRepository;publicCSTSecurityMetadataSource(URLServiceurlService,RoleRepositoryroleRepository){this.urlService=urlService;this.roleRepository=roleRepository;}@OverridepublicCollection&lt;ConfigAttribute&gt;getAttributes(Objecto)throwsIllegalArgumentException{Stringurl=((FilterInvocation)o).getRequestUrl();Collection&lt;ConfigAttribute&gt;configAttributes=newHashSet&lt;&gt;();Set&lt;Role&gt;roles=urlService.getCacheURL(url);roles.forEach(ele-&gt;configAttributes.add(newSecurityConfig(ele.getAuth())));if(configAttributes.isEmpty()){configAttributes.add(newSecurityConfig(DEFAULT_ROLE));}returnconfigAttributes;}@OverridepublicCollection&lt;ConfigAttribute&gt;getAllConfigAttributes(){Collection&lt;ConfigAttribute&gt;configAttributes=newHashSet&lt;&gt;();roleRepository.findAllByDeletedIsFalse().forEach(e-&gt;configAttributes.add(newSecurityConfig(e.getAuth())));returnconfigAttributes;}@Overridepublicbooleansupports(Class&lt;?&gt;aClass){returntrue;}}AccessDecisionManager投票管理器，接口规定了用户权限和URL权限之间的逻辑，即满足某种情况拒绝或者允许。packagecom.auth.frame.security.processor;importorg.springframework.security.access.AccessDecisionManager;importorg.springframework.security.access.AccessDeniedException;importorg.springframework.security.access.ConfigAttribute;importorg.springframework.security.authentication.InsufficientAuthenticationException;importorg.springframework.security.core.Authentication;importjava.util.Collection;importstaticcom.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE;/***@ClassNameCSTAccessDecisionManager*@AuthorWFS*@Date2020/1/2117:06*/publicclassCSTAccessDecisionManagerimplementsAccessDecisionManager{@Overridepublicvoiddecide(Authenticationauthentication,Objecto,Collection&lt;ConfigAttribute&gt;collection)throwsAccessDeniedException,InsufficientAuthenticationException{if(collection.size()==1&amp;&amp;collection.stream().anyMatch(ele-&gt;DEFAULT_ROLE.equals(ele.getAttribute()))){return;}if(!collection.stream().allMatch(ele-&gt;authentication.getAuthorities().stream().anyMatch(e-&gt;ele.getAttribute().equals(e.getAuthority())))){thrownewAccessDeniedException(&quot;AccessDenied!&quot;);}}@Overridepublicbooleansupports(ConfigAttributeconfigAttribute){returnBoolean.TRUE;}@Overridepublicbooleansupports(Class&lt;?&gt;aClass){returnBoolean.TRUE;}}Authentication中包含有用户的权限信息，Collection&lt;ConfigAttribute&gt;包含有当前URL需要的权限信息，根据这两个参数我们就可以自由的指定我们投票规则。比如：某个URL含有多个权限，某个用户只要拥有其中一个就可以访问，或者要求必须全部拥有对应的权限才可以访问，此处可以自由发挥。需要注意的是，AccessDecisionManager不起作用的情况，原因是如果Collection&lt;ConfigAttribute&gt;为null或者empty，则不会执行投票器，所以我们需要给没有配置权限的URL一个默认权限。tokenFiltertokenFilter主要用来检查是否登陆的逻辑。先从请求里面获取token，解密，然后从reids里面获取相关权限信息；如果没有token则检查是否是用户名和密码，如果存在那么验证用户名和密码是否匹配，然后生成授权信息，存入redis，返回token给前端。packagecom.auth.frame.security.processor;importcom.auth.frame.common.ResponseEntity;importcom.auth.frame.common.Utils.JSONUtil;importcom.auth.frame.common.Utils.StringUtil;importcom.auth.frame.security.Utils.TokenUtil;importcom.auth.frame.security.bean.User;importcom.auth.frame.security.repository.UserRepository;importorg.springframework.data.redis.core.RedisTemplate;importorg.springframework.security.authentication.UsernamePasswordAuthenticationToken;importorg.springframework.security.core.context.SecurityContextHolder;importorg.springframework.stereotype.Component;importorg.springframework.util.DigestUtils;importjavax.annotation.Resource;importjavax.servlet.*;importjavax.servlet.http.HttpServletRequest;importjavax.servlet.http.HttpServletResponse;importjava.io.IOException;importjava.nio.charset.StandardCharsets;importjava.util.Set;importjava.util.UUID;importjava.util.concurrent.TimeUnit;/***@ClassNameTokenFilter*@AuthorWFS*@Date2020/1/2110:47*/@ComponentpublicclassTokenFilterimplementsFilter{privatefinalUserRepositoryuserRepository;@Resource(name=&quot;sysTokenRedisTemplate&quot;)publicRedisTemplate&lt;String,String&gt;redisTemplate;privatestaticfinalStringusernameParameter=&quot;username&quot;;privatestaticfinalStringpasswordParameter=&quot;password&quot;;publicTokenFilter(UserRepositoryuserRepository){this.userRepository=userRepository;}@Overridepublicvoidinit(FilterConfigfilterConfig){}@Overridepublicvoiddestroy(){}@OverridepublicvoiddoFilter(ServletRequestservletRequest,ServletResponseservletResponse,FilterChainfilterChain)throwsIOException,ServletException{HttpServletRequestrequest=(HttpServletRequest)servletRequest;HttpServletResponseresponse=(HttpServletResponse)servletResponse;Stringrds=TokenUtil.getBody(request);if(rds==null){Stringusername=request.getParameter(usernameParameter);Stringpassword=request.getParameter(passwordParameter);if(!StringUtil.isNullOrEmpty(username,password)){Useruser=userRepository.findByDeletedIsFalseAndUserName(username);if(user!=null){if(user.getAccountNonExpired()&amp;&amp;user.getAccountNonLocked()&amp;&amp;user.getCredentialsNonExpired()&amp;&amp;user.getEnabled()){if(!StringUtil.isNullOrEmpty(user.getSalt(),user.getPassWord())){if(user.getPassWord().equals(DigestUtils.md5DigestAsHex((password+user.getSalt()).getBytes(StandardCharsets.UTF_8)))){Set&lt;String&gt;rdsSet=redisTemplate.keys(&quot;*&quot;);if(rdsSet!=null){for(Strings:rdsSet){Stringrc=redisTemplate.opsForValue().get(s);if(rc!=null){CSTUserDetailsrc_u=JSONUtil.json2Obj(rc,CSTUserDetails.class);if(rc_u!=null){if(user.getId().equals(rc_u.getUserId())){redisTemplate.delete(s);}}}}}CSTUserDetailscstUserDetails=newCSTUserDetails(user);Stringr=UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);redisTemplate.opsForValue().set(r,JSONUtil.obj2Json(cstUserDetails));redisTemplate.expire(r,2,TimeUnit.HOURS);Stringtoken=TokenUtil.create(r);ResponseEntity.ofToken(response,token);return;}}}}}}else{StringcuStr=redisTemplate.opsForValue().get(rds);if(!StringUtil.isNullOrEmpty(cuStr)){CSTUserDetailscu=JSONUtil.json2Obj(cuStr,CSTUserDetails.class);if(cu!=null){if(cu.getAccountNonExpired()&amp;&amp;cu.getAccountNonLocked()&amp;&amp;cu.getCredentialsNonExpired()&amp;&amp;cu.getEnabled()){SecurityContextHolder.getContext().setAuthentication(newUsernamePasswordAuthenticationToken(cu.getUserId(),cu.getPassword(),cu.getAuthorities()));}}}}filterChain.doFilter(servletRequest,servletResponse);}}TokenUtil主要从request里面解析token里面的rds中间有一段redis的操作，此处可以自行拓展，即每一个新的附带密码的请求都去删除redis里面相同userId的授权信息，这样做的好处是可以保证每个账号同一个时间只有一个人登陆。ResponseEntity.ofToken()工具类，用于向response返回信息配置springsecurity设置withObjectPostProcessor来设置AccessDecisionManager和SecurityMetadataSource，addFilterBefore设置TokenFilter的位置，web.ignoring设置开放API的路径，开放API不受springsecurity过滤链的控制。packagecom.auth.frame.security.config;importcom.auth.frame.security.processor.CSTAccessDecisionManager;importcom.auth.frame.security.processor.CSTSecurityMetadataSource;importcom.auth.frame.security.processor.CSTUserDetailsService;importcom.auth.frame.security.processor.TokenFilter;importcom.auth.frame.security.repository.RoleRepository;importcom.auth.frame.security.service.URLService;importorg.springframework.context.annotation.Bean;importorg.springframework.context.annotation.Configuration;importorg.springframework.security.config.annotation.ObjectPostProcessor;importorg.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;importorg.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;importorg.springframework.security.config.annotation.web.builders.HttpSecurity;importorg.springframework.security.config.annotation.web.builders.WebSecurity;importorg.springframework.security.config.annotation.web.configuration.EnableWebSecurity;importorg.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;importorg.springframework.security.config.http.SessionCreationPolicy;importorg.springframework.security.web.access.intercept.FilterSecurityInterceptor;importorg.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;importorg.springframework.web.cors.CorsUtils;/***@ClassNameSecurityConfig*@AuthorWFS*@Date2020/1/2110:25*/@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(jsr250Enabled=true)publicclassSecurityConfigextendsWebSecurityConfigurerAdapter{privatefinalCSTUserDetailsServicecstUserDetailsService;privatefinalApplicationSecurityConfigapplicationSecurityConfig;privatefinalTokenFiltertokenFilter;privatefinalURLServiceurlService;privatefinalRoleRepositoryroleRepository;publicSecurityConfig(CSTUserDetailsServicecstUserDetailsService,ApplicationSecurityConfigapplicationSecurityConfig,TokenFiltertokenFilter,URLServiceurlService,RoleRepositoryroleRepository){this.cstUserDetailsService=cstUserDetailsService;this.applicationSecurityConfig=applicationSecurityConfig;this.tokenFilter=tokenFilter;this.urlService=urlService;this.roleRepository=roleRepository;}@Overrideprotectedvoidconfigure(AuthenticationManagerBuilderauth)throwsException{auth.userDetailsService(cstUserDetailsService);}@BeanpublicCSTAccessDecisionManagergetCSTAccessDecisionManager(){returnnewCSTAccessDecisionManager();}@BeanpublicCSTSecurityMetadataSourcegetCSTSecurityMetadataSource(){returnnewCSTSecurityMetadataSource(urlService,roleRepository);}@Overrideprotectedvoidconfigure(HttpSecurityhttp)throwsException{http.csrf().disable().cors().and().authorizeRequests().withObjectPostProcessor(newObjectPostProcessor&lt;FilterSecurityInterceptor&gt;(){@Overridepublic&lt;OextendsFilterSecurityInterceptor&gt;OpostProcess(Oo){o.setAccessDecisionManager(getCSTAccessDecisionManager());o.setSecurityMetadataSource(getCSTSecurityMetadataSource());returno;}}).requestMatchers(CorsUtils::isPreFlightRequest).permitAll().anyRequest().authenticated().and().anonymous().disable().formLogin().permitAll().and().addFilterBefore(tokenFilter,UsernamePasswordAuthenticationFilter.class).sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);}@Overridepublicvoidconfigure(WebSecurityweb){web.ignoring().regexMatchers(applicationSecurityConfig.getOpenApi());}}结语通过以上逻辑，token登陆和自定义权限功能已经完成，其实所有的功能实现集中于UserDetails的构建和AccessDecisionManager投票逻辑，熟知于此就可以随意拓展Filter来实现自己的功能。","link":"https://fikacode.github.io/post/springSecurityTokenLogin/"},{"title":"excel强制启用VBA","content":"事实上VBA的启用依赖于运行的容器，VBA本身没有强制启用的功能。但是我们可以用另外一种方法来实现强制启用的功能：如果不启用那么，显示一个页面，提示启用；如果启用就隐藏提示，显示正文。大概代码如下：PrivateSubWorkbook_BeforeClose(CancelAsBoolean)DimshAsWorksheetForEachshtInWorksheetsIfsht.Name&lt;&gt;”Welcome”ThenSheets(sht.Name).Visible=FalseEndIfNextSheets(“Welcome”).Visible=TrueSheets(“Welcome”).SelectThisWorkbook.SaveEndSubPrivateSubWorkbook_Open()DimshtAsWorksheetForEachshtInWorksheetsIfsht.Name&lt;&gt;”Welcome”Thensht.Visible=xlSheetVisibleEndIfNextWorksheets(“Welcome”).Visible=xlSheetVeryHiddenThisWorkbook.SaveEndSub代码很好理解：关闭之前，隐藏所有sheet，只显示Welcome；打开文件隐藏Welcome，显示正文。","link":"https://fikacode.github.io/post/excelForceEnableVba/"},{"title":"spring boot 打包为外置 tomcat (war)","content":"修改pom文件&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;!--移除嵌入式tomcat插件--&gt;&lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/exclusion&gt;&lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;javax.servlet&lt;/groupId&gt;&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;version&gt;4.0.1&lt;/version&gt;&lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;修改Application启动类修改前publicclassApplication{publicstaticvoidmain(String[]args){SpringApplication.run(Application.class,args);}}修改后publicclassApplicationextendsSpringBootServletInitializer{@OverrideprotectedSpringApplicationBuilderconfigure(SpringApplicationBuilderbuilder){returnbuilder.sources(Application.class);}publicstaticvoidmain(String[]args){SpringApplication.run(Application.class,args);}}特别注意如果使用了websocket，那么需要注释掉下面的代码，同时添加websocket的支持。@ConfigurationpublicclassWebSocketConfig{//@Bean//publicServerEndpointExporterserverEndpointExporter(){//returnnewServerEndpointExporter();//}}&lt;!--https://mvnrepository.com/artifact/javax.websocket/javax.websocket-api--&gt;&lt;dependency&gt;&lt;groupId&gt;javax.websocket&lt;/groupId&gt;&lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;&lt;version&gt;1.1&lt;/version&gt;&lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;如果使用了注解@WebFilter，那么需要使用FilterRegistrationBean的方式来注册Filter。","link":"https://fikacode.github.io/post/springbootPackageToWar/"},{"title":"tomcat 常用的优化","content":"catalina设置java参数setCATALINA_OPTS=-Dfile.encoding=UTF-8-server-Xms8192m-Xmx8192m-Xmn4096m-XX:SurvivorRatio=10-XX:MaxTenuringThreshold=15-XX:NewRatio=2-XX:+DisableExplicitGC根据环境的配置优化相关参数Server.xml设置连接池&lt;Executorname=&quot;tomcatThreadPool&quot;namePrefix=&quot;catalina-exec-&quot;maxThreads=&quot;500&quot;minSpareThreads=&quot;100&quot;prestartminSpareThreads=&quot;true&quot;maxQueueSize=&quot;100&quot;/&gt;开启压缩和NIO2&lt;Connectorexecutor=&quot;tomcatThreadPool&quot;port=&quot;80&quot;protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;connectionTimeout=&quot;20000&quot;maxConnections=&quot;10000&quot;redirectPort=&quot;8443&quot;enableLookups=&quot;false&quot;acceptCount=&quot;100&quot;maxPostSize=&quot;10485760&quot;compression=&quot;on&quot;disableUploadTimeout=&quot;true&quot;compressionMinSize=&quot;50&quot;acceptorThreadCount=&quot;4&quot;compressableMimeType=&quot;text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/x-javascript,application/json,image/jpg,application/x-font-ttf,application/x-font-otf,image/svg+xml,image/jpeg,image/png,image/gif,audio/mpeg,video/mp4,font/woff&quot;URIEncoding=&quot;utf-8&quot;/&gt;web.xml设置缓存&lt;filter&gt;&lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.apache.catalina.filters.ExpiresFilter&lt;/filter-class&gt;&lt;init-param&gt;&lt;param-name&gt;ExpiresByTypeimage&lt;/param-name&gt;&lt;param-value&gt;accessplus30days&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;ExpiresByTypetext&lt;/param-name&gt;&lt;param-value&gt;accessplus30days&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;ExpiresByTypeapplication/javascript&lt;/param-name&gt;&lt;param-value&gt;accessplus30days&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;ExpiresByTypemultipart/form-data&lt;/param-name&gt;&lt;param-value&gt;accessplus30days&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;ExpiresByTypefont/woff&lt;/param-name&gt;&lt;param-value&gt;accessplus30days&lt;/param-value&gt;&lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt;","link":"https://fikacode.github.io/post/tomcatOptimizationAndCache/"},{"title":"java 将数组均分为多个数组","content":"将一组数据平均分成n组/***将一组数据平均分成n组**@paramsource要分组的数据源*@paramn平均分成n组*@param&lt;T&gt;*@return*/publicstatic&lt;T&gt;List&lt;List&lt;T&gt;&gt;averageAssign(List&lt;T&gt;source,intn){List&lt;List&lt;T&gt;&gt;result=newArrayList&lt;List&lt;T&gt;&gt;();intremainder=source.size()%n;//(先计算出余数)intnumber=source.size()/n;//然后是商intoffset=0;//偏移量for(inti=0;i&lt;n;i++){List&lt;T&gt;value=null;if(remainder&gt;0){value=source.subList(i*number+offset,(i+1)*number+offset+1);remainder--;offset++;}else{value=source.subList(i*number+offset,(i+1)*number+offset);}result.add(value);}returnresult;}将一组数据固定分组，每组n个元素/***将一组数据固定分组，每组n个元素*@paramsource要分组的数据源*@paramn每组n个元素*@param&lt;T&gt;*@return*/publicstatic&lt;T&gt;List&lt;List&lt;T&gt;&gt;fixedGrouping(List&lt;T&gt;source,intn){if(null==source||source.size()==0||n&lt;=0)returnnull;List&lt;List&lt;T&gt;&gt;result=newArrayList&lt;List&lt;T&gt;&gt;();intsourceSize=source.size();intsize=(source.size()/n)+1;for(inti=0;i&lt;size;i++){List&lt;T&gt;subset=newArrayList&lt;T&gt;();for(intj=i*n;j&lt;(i+1)*n;j++){if(j&lt;sourceSize){subset.add(source.get(j));}}result.add(subset);}returnresult;}将一组数据固定分组，每组n个元素/***将一组数据固定分组，每组n个元素，第二种写法**@paramsource要分组的数据源*@paramn每组n个元素*@param&lt;T&gt;*@return*/publicstatic&lt;T&gt;List&lt;List&lt;T&gt;&gt;fixedGrouping2(List&lt;T&gt;source,intn){if(null==source||source.size()==0||n&lt;=0)returnnull;List&lt;List&lt;T&gt;&gt;result=newArrayList&lt;List&lt;T&gt;&gt;();intremainder=source.size()%n;intsize=(source.size()/n);for(inti=0;i&lt;size;i++){List&lt;T&gt;subset=null;subset=source.subList(i*n,(i+1)*n);result.add(subset);}if(remainder&gt;0){List&lt;T&gt;subset=null;subset=source.subList(size*n,size*n+remainder);result.add(subset);}returnresult;}","link":"https://fikacode.github.io/post/javaListAverage/"}]}