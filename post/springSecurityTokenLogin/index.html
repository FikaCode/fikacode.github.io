<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[Drinker]的个人博客">
<meta name="author" content="kveln">
<title>Spring Security 自定义权限实现 redis token 登陆验证 | Drinker</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="Spring Security 自定义权限实现 redis token 登陆验证 | Drinker » Feed"
  href="https://fikacode.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://fikacode.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="Spring Security 自定义权限实现 redis token 登陆验证" />
  <meta property="og:url" content="https://fikacode.github.io/post/springSecurityTokenLogin/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Drinker" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://fikacode.github.io">Drinker</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1609843076132"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://fikacode.github.io">Drinker</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1609843076132"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://fikacode.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://fikacode.github.io/tag/springSecurity/" class="tag">spring security</a>
                
                <a href="https://fikacode.github.io/tag/spring boot/" class="tag">spring boot</a>
                
                <a href="https://fikacode.github.io/tag/Java/" class="tag">Java</a>
                
              </span>
              <h1>Spring Security 自定义权限实现 redis token 登陆验证</h1>
              <span class="meta">
                Posted on
                2020-12-30，20 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <h2 id="前言">前言</h2>
<p>  本文的实现方式主要针于与对<code>spring security</code>有所了解的读者，通过增加<code>filter</code>的方式，替换代替<code>spring security</code>自带的的能登陆逻辑。</p>
<h2 id="准备工作">准备工作</h2>
<h4 id="pom-配置">pom 配置</h4>
<pre><code>    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

   &lt;dependencies&gt;
        &lt;!-- spring security --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;3.2.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- JPA --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 链接mysql --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- jwt --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.auth0&lt;/groupId&gt;
            &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;
            &lt;version&gt;3.9.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<blockquote>
<p>其他的pom配置这里不在贴出，有需要的可自行添加。</p>
</blockquote>
<h4 id="redis-配置">redis 配置</h4>
<p>  RedisTemplate要来读取缓存在redis里面的token，登陆的时候需要使用到。这里为了以后扩展方便，使用RedisStandaloneConfiguration的方式配置RedisTemplate，可以自由配置端口和数据库。<br>
<br/></p>
<pre><code>package com.auth.frame.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.jedis.JedisClientConfiguration;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

/**
 * @ClassName SecurityRedisConfig
 * @Author WFS
 * @Date 2020/1/21 15:56
 */
@Configuration
public class SecurityRedisConfig {

    @Bean(&quot;sysTokenRedisTemplate&quot;)
    public RedisTemplate&lt;String, String&gt; getTokenRedisTemplate() {
        return buildRedisTemplateByDataBase(10);
    }

    private RedisTemplate&lt;String, String&gt; buildRedisTemplateByDataBase(Integer dataBase) {
        RedisTemplate&lt;String, String&gt; template = new StringRedisTemplate();
        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
        redisStandaloneConfiguration.setHostName(&quot;localhost&quot;);
        redisStandaloneConfiguration.setPort(6379);
        redisStandaloneConfiguration.setDatabase(dataBase);
        JedisClientConfiguration.JedisClientConfigurationBuilder clientConfiguration = JedisClientConfiguration.builder();
        clientConfiguration.connectTimeout(Duration.ofSeconds(60));
        JedisConnectionFactory codeFactory = new JedisConnectionFactory(redisStandaloneConfiguration,
                clientConfiguration.build());
        template.setConnectionFactory(codeFactory);
        template.setValueSerializer(new StringRedisSerializer());
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new StringRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}

</code></pre>
<h4 id="跨域配置">跨域配置</h4>
<p>  一般使用token的都是前后端分离，跨域这个问题总是要解决。springboot框架自带跨域的filter的配置，但是那个配置有些时候老是会有问题，我建议自己配置filter的方式来增加跨域的支持。</p>
<pre><code>package com.auth.frame.security.processor;

import org.springframework.web.bind.annotation.RequestMethod;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @ClassName CROSFilter
 * @Author WFS
 * @Date 2020/2/7/0007 16:58
 */
public class CORSFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String origin = request.getHeader(&quot;Origin&quot;);
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
        response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);
        response.addHeader(&quot;Access-Control-Allow-Headers&quot;,
                &quot;Content-Type, Authorization&quot;);
        response.addHeader(&quot;Access-Control-Allow-Credentials&quot;,
                &quot;true&quot;);
        if (RequestMethod.OPTIONS.toString().equals(request.getMethod())) {
            servletResponse.getWriter().println(&quot;ok&quot;);
            return;
        }
        filterChain.doFilter(request ,response);
    }

    @Override
    public void init(FilterConfig filterConfig) {

    }

    @Override
    public void destroy() {

    }
}
</code></pre>
<p>注册Filter</p>
<pre><code>package com.auth.frame.security.config;

import com.auth.frame.security.processor.CORSFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @ClassName FilterConfig
 * @Author WFS
 * @Date 2020/2/7/0007 16:57
 */
@Configuration
public class FilterConfig {
    @Bean(name = &quot;CORSFilter&quot;)
    public FilterRegistrationBean&lt;CORSFilter&gt; setFilter() {
        FilterRegistrationBean&lt;CORSFilter&gt; filterBean = new FilterRegistrationBean&lt;&gt;();
        filterBean.setFilter(new CORSFilter());
        filterBean.setOrder(Integer.MIN_VALUE);
        filterBean.setName(&quot;CORSFilter&quot;);
        filterBean.addUrlPatterns(&quot;/*&quot;);
        return filterBean;
    }
}

</code></pre>
<blockquote>
<ol>
<li>其余的选项可以按照自己的需求配置filter</li>
<li>filterBean.setOrder(Integer.MIN_VALUE); 保证了filter 第一个执行。</li>
</ol>
</blockquote>
<h2 id="原理">原理</h2>
<ol>
<li>
<h4 id="token-登陆">token 登陆</h4>
</li>
</ol>
<p>  spring security是由一大批filter组成，其中<code>UsernamePasswordAuthenticationFilter</code>是用户登陆验证时候的filter，我们要做的就是登陆验证之前检验token，如果token符合我们规则，那么从token里面取出授权信息，然后在<code>SecurityContextHolder</code>里面增加授权信息。这样，后面经过<code>UsernamePasswordAuthenticationFilter</code>时就不会使用自带的登陆验证逻辑检验。如果token不符合规则，直接滤过，<code>UsernamePasswordAuthenticationFilter</code>检验没有授权信息，会引导到登陆页面。</p>
<ol start="2">
<li>
<h4 id="自定义用户权限">自定义用户权限</h4>
</li>
</ol>
<p>  自定义用户权限主要用户来配合token做权限判断，从token里面取出来的授权信息就是关联我们的自定义权限。要实现自定义权限我们需要实现三个接口：<code>UserDetailsService</code>，该接口主要获取用户对应的权限；<code>FilterInvocationSecurityMetadataSource</code>启动项目时候所有url的权限信息；<code>AccessDecisionManager</code>投票器，根据用户的权限信息和url权限信息来实现允许或者拒绝的逻辑。</p>
<h2 id="用户信息表">用户信息表</h2>
<ol>
<li>
<h4 id="用户表">用户表</h4>
</li>
</ol>
<pre><code>package com.auth.frame.security.bean;


import com.auth.frame.common.BaseEntity;
import lombok.*;

import javax.persistence.*;
import java.util.Set;


@EqualsAndHashCode(callSuper = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;t_sys_user&quot;, indexes = {@Index(columnList = &quot;id&quot;), @Index(columnList = &quot;phoneNum&quot;)})
public class User extends BaseEntity {
    @Column(unique = true)
    private String phoneNum;
    @Column(unique = true)
    private String userName;
    @Column
    private String salt;
    @Column
    private String passWord;
    @Column
    private Boolean accountNonExpired;
    @Column
    private Boolean accountNonLocked;
    @Column
    private Boolean credentialsNonExpired;
    @Column
    private Boolean enabled;
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = &quot;t_sys_user_role&quot;, joinColumns = {@JoinColumn(name = &quot;user_id&quot;, referencedColumnName = &quot;id&quot;)}
            , inverseJoinColumns = {@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)})
    private Set&lt;Role&gt; roles;

}
</code></pre>
<ol start="2">
<li>
<h4 id="角色表">角色表</h4>
</li>
</ol>
<pre><code>package com.auth.frame.security.bean;

import com.auth.frame.common.BaseEntity;
import lombok.*;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Index;
import javax.persistence.Table;

@EqualsAndHashCode(callSuper = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;t_sys_role&quot;, indexes = {@Index(columnList = &quot;id&quot;)})
public class Role extends BaseEntity {
    @Column
    private String name;
    @Column
    private String auth;
}
</code></pre>
<ol start="3">
<li>
<h4 id="url表">URL表</h4>
</li>
</ol>
<pre><code>package com.auth.frame.security.bean;


import com.auth.frame.common.BaseEntity;
import lombok.*;

import javax.persistence.*;
import java.util.Set;


@EqualsAndHashCode(callSuper = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;t_sys_url&quot;, indexes = {@Index(columnList = &quot;id&quot;)})
public class URL extends BaseEntity {
    @Column
    private String name;
    @Column
    private String path;

    @ManyToMany (fetch = FetchType.EAGER)
    @JoinTable(name = &quot;t_sys_url_role&quot;, joinColumns = {@JoinColumn(name = &quot;url_id&quot;, referencedColumnName = &quot;id&quot;)}
            , inverseJoinColumns = {@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)})
    private Set&lt;Role&gt; roles;
}
</code></pre>
<blockquote>
<ol>
<li>BaseEntity 主要是提供主键和创建、修改时间的字段。</li>
<li>注解中使用了 lombok。</li>
<li>角色、用户和URL使用的是单边对应，如有需要可改为多边对应。</li>
</ol>
</blockquote>
<h2 id="自定义认证">自定义认证</h2>
<ol>
<li>
<h4 id="userdetails">UserDetails</h4>
</li>
</ol>
<p>  UserDetails是spring security中的用户信息接口，通过实现UserDetails可以和User表关联起来。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.security.bean.User;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;

/**
 * @ClassName CSTUserDetailService
 * @Author WFS
 * @Date 2020/1/21 10:39
 */
@NoArgsConstructor
@AllArgsConstructor
@Data
public class CSTUserDetails implements UserDetails {
    private Collection&lt;SimpleGrantedAuthority&gt; authorities;
    private String username;
    private String userId;
    private Boolean accountNonExpired;
    private Boolean accountNonLocked;
    private Boolean credentialsNonExpired;
    private Boolean enabled;

    public CSTUserDetails(Collection&lt;SimpleGrantedAuthority&gt; authorities, String username, String userId, boolean accountNonExpired, boolean accountNonLocked, boolean credentialsNonExpired, boolean enabled) {
        this.authorities = authorities;
        this.username = username;
        this.userId = userId;
        this.accountNonExpired = accountNonExpired;
        this.accountNonLocked = accountNonLocked;
        this.credentialsNonExpired = credentialsNonExpired;
        this.enabled = enabled;
    }

    public CSTUserDetails(User user) {
        this.authorities = CSTUserDetailsService.getAuthorities(user);
        this.username = user.getUserName();
        this.userId = user.getId();
        this.accountNonExpired = user.getAccountNonExpired();
        this.accountNonLocked = user.getAccountNonLocked();
        this.credentialsNonExpired = user.getCredentialsNonExpired();
        this.enabled = user.getEnabled();
    }


    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return null;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return accountNonExpired;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return credentialsNonExpired;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}
</code></pre>
<blockquote>
<p><code>authorities</code>是用户对应的权限，其实就是一个字符串列表，可以自行拓展。</p>
</blockquote>
<ol start="2">
<li>
<h4 id="userdetailsservice">UserDetailsService</h4>
</li>
</ol>
<p>  UserDetailsService接口规定了通过用户名获取用户信息的接口，即获取UserDetails。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.security.bean.Role;
import com.auth.frame.security.bean.User;
import com.auth.frame.security.service.UserService;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * @ClassName CSTUserDetailsService
 * @Author WFS
 * @Date 2020/1/21 10:50
 */
@Component
public class CSTUserDetailsService implements UserDetailsService {


    private final UserService userService;

    public CSTUserDetailsService(UserService userService) {
        this.userService = userService;
    }

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        User user = userService.getCacheUser(s);
        if (user == null) {
            throw new UsernameNotFoundException(&quot;User Not Find!&quot;);
        } else {
            Collection&lt;SimpleGrantedAuthority&gt; authorities = getAuthorities(user);
            return new CSTUserDetails(authorities, user.getUserName(), user.getId(), user.getAccountNonExpired(), user.getAccountNonLocked(), user.getCredentialsNonExpired(), user.getEnabled());
        }
    }

    public static Collection&lt;SimpleGrantedAuthority&gt; getAuthorities(User user) {
        Set&lt;Role&gt; roleSet = user.getRoles();
        Collection&lt;SimpleGrantedAuthority&gt; authorities = new HashSet&lt;&gt;();
        if (roleSet != null &amp;&amp; !roleSet.isEmpty()) {
            roleSet.forEach(role -&gt; authorities.add(new SimpleGrantedAuthority(role.getAuth())));
        }
        return authorities;
    }
}
</code></pre>
<blockquote>
<p><code>loadUserByUsername</code>函数中的参数<code>s</code>即为用户名，<code>userService.getCacheUser</code>的作用是根据用户名获取用户，此处使用的自己写的从缓存获取用户名，可以自由发挥，只要能构建<code>UserDetails</code>即可。</p>
</blockquote>
<ol start="3">
<li>
<h4 id="filterinvocationsecuritymetadatasource">FilterInvocationSecurityMetadataSource</h4>
</li>
</ol>
<p>  <code>FilterInvocationSecurityMetadataSource</code>元数据，接口获取的是全部URL的权限信息和当http请求过来时候url对应的权限。其中<code>getAttributes</code>的参数<code>o</code>包含了当前访问的URL，根据URL我们需要返回对应的权限信息；<code>getAllConfigAttributes</code>会在项目启动时执行一次，获取所有URL对应的权限信息。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.security.bean.Role;
import com.auth.frame.security.repository.RoleRepository;
import com.auth.frame.security.service.URLService;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.access.SecurityConfig;
import org.springframework.security.web.FilterInvocation;
import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import static com.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE;

/**
 * @ClassName CSTSecurityMetadataSource
 * @Author WFS
 * @Date 2020/1/21 17:06
 */
public class CSTSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {

    private URLService urlService;

    private RoleRepository roleRepository;

    public CSTSecurityMetadataSource(URLService urlService, RoleRepository roleRepository) {
        this.urlService = urlService;
        this.roleRepository = roleRepository;
    }

    @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException {
        String url = ((FilterInvocation) o).getRequestUrl();
        Collection&lt;ConfigAttribute&gt; configAttributes = new HashSet&lt;&gt;();
        Set&lt;Role&gt; roles = urlService.getCacheURL(url);
        roles.forEach(ele -&gt; configAttributes.add(new SecurityConfig(ele.getAuth())));
        if (configAttributes.isEmpty()) {
            configAttributes.add(new SecurityConfig(DEFAULT_ROLE));
        }
        return configAttributes;
    }

    @Override
    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() {
        Collection&lt;ConfigAttribute&gt; configAttributes = new HashSet&lt;&gt;();
        roleRepository.findAllByDeletedIsFalse().forEach(e -&gt; configAttributes.add(new SecurityConfig(e.getAuth())));
        return configAttributes;
    }

    @Override
    public boolean supports(Class&lt;?&gt; aClass) {
        return true;
    }
}
</code></pre>
<ol start="4">
<li>
<h4 id="accessdecisionmanager">AccessDecisionManager</h4>
</li>
</ol>
<p>  投票管理器，接口规定了用户权限和URL权限之间的逻辑，即满足某种情况拒绝或者允许。</p>
<pre><code>package com.auth.frame.security.processor;

import org.springframework.security.access.AccessDecisionManager;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.Authentication;

import java.util.Collection;

import static com.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE;

/**
 * @ClassName CSTAccessDecisionManager
 * @Author WFS
 * @Date 2020/1/21 17:06
 */
public class CSTAccessDecisionManager implements AccessDecisionManager {
    @Override
    public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException {
        if (collection.size() == 1 &amp;&amp; collection.stream().anyMatch(ele -&gt; DEFAULT_ROLE.equals(ele.getAttribute()))) {
            return;
        }
        if (!collection.stream().allMatch(ele -&gt; authentication.getAuthorities().stream().anyMatch(e -&gt; ele.getAttribute().equals(e.getAuthority())))) {
            throw new AccessDeniedException(&quot;AccessDenied!&quot;);
        }
    }

    @Override
    public boolean supports(ConfigAttribute configAttribute) {
        return Boolean.TRUE;
    }

    @Override
    public boolean supports(Class&lt;?&gt; aClass) {
        return Boolean.TRUE;
    }
}
</code></pre>
<p>  <code>Authentication</code>中包含有用户的权限信息，<code>Collection&lt;ConfigAttribute&gt;</code>包含有当前URL需要的权限信息，根据这两个参数我们就可以自由的指定我们投票规则。比如：某个URL含有多个权限，某个用户只要拥有其中一个就可以访问，或者要求必须全部拥有对应的权限才可以访问，此处可以自由发挥。需要注意的是，<strong><code>AccessDecisionManager</code>不起作用的情况，原因是如果<code>Collection&lt;ConfigAttribute&gt;</code>为<code>null</code>或者<code>empty</code>，则不会执行投票器，所以我们需要给没有配置权限的URL一个默认权限。</strong></p>
<h2 id="tokenfilter">tokenFilter</h2>
<p>  tokenFilter主要用来检查是否登陆的逻辑。先从请求里面获取token，解密，然后从reids里面获取相关权限信息；如果没有token则检查是否是用户名和密码，如果存在那么验证用户名和密码是否匹配，然后生成授权信息，存入redis，返回token给前端。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.common.ResponseEntity;
import com.auth.frame.common.Utils.JSONUtil;
import com.auth.frame.common.Utils.StringUtil;
import com.auth.frame.security.Utils.TokenUtil;
import com.auth.frame.security.bean.User;
import com.auth.frame.security.repository.UserRepository;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.util.DigestUtils;

import javax.annotation.Resource;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * @ClassName TokenFilter
 * @Author WFS
 * @Date 2020/1/21 10:47
 */
@Component
public class TokenFilter implements Filter {


    private final UserRepository userRepository;

    @Resource(name = &quot;sysTokenRedisTemplate&quot;)
    public RedisTemplate&lt;String, String&gt; redisTemplate;

    private static final String usernameParameter = &quot;username&quot;;
    private static final String passwordParameter = &quot;password&quot;;

    public TokenFilter(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public void init(FilterConfig filterConfig) {

    }

    @Override
    public void destroy() {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String rds = TokenUtil.getBody(request);
        if (rds == null) {
            String username = request.getParameter(usernameParameter);
            String password = request.getParameter(passwordParameter);
            if (!StringUtil.isNullOrEmpty(username, password)) {
                User user = userRepository.findByDeletedIsFalseAndUserName(username);
                if (user != null) {
                    if (user.getAccountNonExpired() &amp;&amp; user.getAccountNonLocked() &amp;&amp; user.getCredentialsNonExpired() &amp;&amp; user.getEnabled()) {
                        if (!StringUtil.isNullOrEmpty(user.getSalt(), user.getPassWord())) {
                            if (user.getPassWord().equals(DigestUtils.md5DigestAsHex((password + user.getSalt()).getBytes(StandardCharsets.UTF_8)))) {
                                Set&lt;String&gt; rdsSet = redisTemplate.keys(&quot;*&quot;);
                                if (rdsSet != null) {
                                    for (String s : rdsSet) {
                                        String rc = redisTemplate.opsForValue().get(s);
                                        if (rc != null) {
                                            CSTUserDetails rc_u = JSONUtil.json2Obj(rc, CSTUserDetails.class);
                                            if (rc_u != null) {
                                                if (user.getId().equals(rc_u.getUserId())) {
                                                    redisTemplate.delete(s);
                                                }
                                            }
                                        }
                                    }
                                }
                                CSTUserDetails cstUserDetails = new CSTUserDetails(user);
                                String r = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);
                                redisTemplate.opsForValue().set(r, JSONUtil.obj2Json(cstUserDetails));
                                redisTemplate.expire(r, 2, TimeUnit.HOURS);
                                String token = TokenUtil.create(r);
                                ResponseEntity.ofToken(response, token);
                                return;
                            }
                        }
                    }
                }
            }
        } else {
            String cuStr = redisTemplate.opsForValue().get(rds);
            if (!StringUtil.isNullOrEmpty(cuStr)) {
                CSTUserDetails cu = JSONUtil.json2Obj(cuStr, CSTUserDetails.class);
                if (cu != null) {
                    if (cu.getAccountNonExpired() &amp;&amp; cu.getAccountNonLocked() &amp;&amp; cu.getCredentialsNonExpired() &amp;&amp; cu.getEnabled()) {
                        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(cu.getUserId(), cu.getPassword(), cu.getAuthorities()));
                    }
                }
            }
        }
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
</code></pre>
<blockquote>
<ol>
<li><code>TokenUtil</code> 主要从<code>request</code>里面解析<code>token</code>里面的<code>rds</code></li>
<li>中间有一段<code>redis</code>的操作，此处可以自行拓展，即每一个新的附带密码的请求都去删除<code>redis</code>里面相同<code>userId</code>的授权信息，这样做的好处是可以保证每个账号同一个时间只有一个人登陆。</li>
<li><code>ResponseEntity.ofToken()</code> 工具类，用于向<code>response</code>返回信息</li>
</ol>
</blockquote>
<h2 id="配置spring-security">配置<code>spring security</code></h2>
<p>  设置<code>withObjectPostProcessor</code>来设置<code>AccessDecisionManager</code>和<code>SecurityMetadataSource</code>，<code>addFilterBefore</code>设置<code>TokenFilter</code>的位置，<code>web.ignoring</code>设置开放<code>API</code>的路径，开放<code>API</code>不受<code>spring security</code>过滤链的控制。</p>
<pre><code>package com.auth.frame.security.config;

import com.auth.frame.security.processor.CSTAccessDecisionManager;
import com.auth.frame.security.processor.CSTSecurityMetadataSource;
import com.auth.frame.security.processor.CSTUserDetailsService;
import com.auth.frame.security.processor.TokenFilter;
import com.auth.frame.security.repository.RoleRepository;
import com.auth.frame.security.service.URLService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.ObjectPostProcessor;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.access.intercept.FilterSecurityInterceptor;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsUtils;

/**
 * @ClassName SecurityConfig
 * @Author WFS
 * @Date 2020/1/21 10:25
 */
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {


    private final CSTUserDetailsService cstUserDetailsService;
    private final ApplicationSecurityConfig applicationSecurityConfig;
    private final TokenFilter tokenFilter;

    private final URLService urlService;
    private final RoleRepository roleRepository;


    public SecurityConfig(CSTUserDetailsService cstUserDetailsService, ApplicationSecurityConfig applicationSecurityConfig, TokenFilter tokenFilter, URLService urlService, RoleRepository roleRepository) {
        this.cstUserDetailsService = cstUserDetailsService;
        this.applicationSecurityConfig = applicationSecurityConfig;
        this.tokenFilter = tokenFilter;
        this.urlService = urlService;
        this.roleRepository = roleRepository;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(cstUserDetailsService);
    }

    @Bean
    public CSTAccessDecisionManager getCSTAccessDecisionManager() {
        return new CSTAccessDecisionManager();
    }

    @Bean
    public CSTSecurityMetadataSource getCSTSecurityMetadataSource() {
        return new CSTSecurityMetadataSource(urlService, roleRepository);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().cors()
                .and().authorizeRequests()
                .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
                    @Override
                    public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) {
                        o.setAccessDecisionManager(getCSTAccessDecisionManager());
                        o.setSecurityMetadataSource(getCSTSecurityMetadataSource());
                        return o;
                    }
                })
                .requestMatchers(CorsUtils::isPreFlightRequest).permitAll()
                .anyRequest().authenticated()
                .and().anonymous().disable().formLogin().permitAll()
                .and().addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class)
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }

    @Override
    public void configure(WebSecurity web) {
        web.ignoring().regexMatchers(applicationSecurityConfig.getOpenApi());
    }
}
</code></pre>
<h2 id="结语">结语</h2>
<p>  通过以上逻辑，token登陆和自定义权限功能已经完成，其实所有的功能实现集中于<code>UserDetails</code>的构建和<code>AccessDecisionManager</code>投票逻辑，熟知于此就可以随意拓展Filter来实现自己的功能。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a><br>
*
<ul>
<li><a href="#pom-%E9%85%8D%E7%BD%AE">pom 配置</a></li>
<li><a href="#redis-%E9%85%8D%E7%BD%AE">redis 配置</a></li>
<li><a href="#%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE">跨域配置</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a><br>
*
<ul>
<li><a href="#token-%E7%99%BB%E9%99%86">token 登陆</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90">自定义用户权限</a></li>
</ul>
</li>
<li><a href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%A1%A8">用户信息表</a><br>
*
<ul>
<li><a href="#%E7%94%A8%E6%88%B7%E8%A1%A8">用户表</a></li>
<li><a href="#%E8%A7%92%E8%89%B2%E8%A1%A8">角色表</a></li>
<li><a href="#url%E8%A1%A8">URL表</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81">自定义认证</a><br>
*
<ul>
<li><a href="#userdetails">UserDetails</a></li>
<li><a href="#userdetailsservice">UserDetailsService</a></li>
<li><a href="#filterinvocationsecuritymetadatasource">FilterInvocationSecurityMetadataSource</a></li>
<li><a href="#accessdecisionmanager">AccessDecisionManager</a></li>
</ul>
</li>
<li><a href="#tokenfilter">tokenFilter</a></li>
<li><a href="#%E9%85%8D%E7%BD%AEspring-security">配置<code>spring security</code></a></li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
</li>
</ul>
</div>
          
          <hr />
          <p class="next-post">下一篇：
            <a href="https://fikacode.github.io/post/excelForceEnableVba/">
              <span class="post-title">
                excel强制启用VBA&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script>
  var gitalk = new Gitalk({
    clientID: 'd66422d3295b07cef117',
    clientSecret: '2c7f613f7801b2f0662c77febbbed703d5eec6af',
    repo: 'fikacode.github.io',
    owner: 'FikaCode',
    admin: ['FikaCode'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>

            
            
            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/FikaCode" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://fikacode.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>Drinker</span><br></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://fikacode.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://fikacode.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://fikacode.github.io/media/live2d/assets/hijiki.model.json");
        });

        var home_Path = "https://fikacode.github.io/";
        addScript("https://fikacode.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://fikacode.github.io/media/scripts/tocScript.js"></script>
</body>

</html>