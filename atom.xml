<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://fikacode.github.io</id>
    <title>Drinker</title>
    <updated>2021-01-06T06:05:03.313Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://fikacode.github.io"/>
    <link rel="self" href="http://fikacode.github.io/atom.xml"/>
    <subtitle>玻璃晴朗，橘子辉煌</subtitle>
    <logo>http://fikacode.github.io/images/avatar.png</logo>
    <icon>http://fikacode.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Drinker</rights>
    <entry>
        <title type="html"><![CDATA[Spring Boot 在非spring控制的组件获取bean]]></title>
        <id>http://fikacode.github.io/post/springbootGetBean/</id>
        <link href="http://fikacode.github.io/post/springbootGetBean/">
        </link>
        <updated>2021-01-04T03:33:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/**
 * @ClassName SpringUtil
 * @Description Spring 工具类
 * @Author WFS
 * @Date 2019/4/3 11:03
 **/

@Component
public class SpringUtil implements ApplicationContextAware {

    private static ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        if (SpringUtil.applicationContext == null) {
            SpringUtil.applicationContext = applicationContext;
        }
    }

    private static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    public static Object getBean(String name) {
        return getApplicationContext().getBean(name);
    }

    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) {
        return getApplicationContext().getBean(clazz);
    }

    public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) {
        return getApplicationContext().getBean(name, clazz);
    }

}
</code></pre>
<h4 id="需要注意几点">需要注意几点</h4>
<blockquote>
<ol>
<li><code>SpringUtil</code>需要被Spring Boot 扫描到</li>
<li>使用的时机需要在<code>spring</code>容器加载完所有Bean以后</li>
</ol>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Security 自定义权限实现 redis token 登陆验证]]></title>
        <id>http://fikacode.github.io/post/springSecurityTokenLogin/</id>
        <link href="http://fikacode.github.io/post/springSecurityTokenLogin/">
        </link>
        <updated>2020-12-30T09:45:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>  本文的实现方式主要针于与对<code>spring security</code>有所了解的读者，通过增加<code>filter</code>的方式，替换代替<code>spring security</code>自带的的能登陆逻辑。</p>
<h2 id="准备工作">准备工作</h2>
<h4 id="pom-配置">pom 配置</h4>
<pre><code>    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

   &lt;dependencies&gt;
        &lt;!-- spring security --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;3.2.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- JPA --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 链接mysql --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- jwt --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.auth0&lt;/groupId&gt;
            &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;
            &lt;version&gt;3.9.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<blockquote>
<p>其他的pom配置这里不在贴出，有需要的可自行添加。</p>
</blockquote>
<h4 id="redis-配置">redis 配置</h4>
<p>  RedisTemplate要来读取缓存在redis里面的token，登陆的时候需要使用到。这里为了以后扩展方便，使用RedisStandaloneConfiguration的方式配置RedisTemplate，可以自由配置端口和数据库。<br>
<br/></p>
<pre><code>package com.auth.frame.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.jedis.JedisClientConfiguration;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

/**
 * @ClassName SecurityRedisConfig
 * @Author WFS
 * @Date 2020/1/21 15:56
 */
@Configuration
public class SecurityRedisConfig {

    @Bean(&quot;sysTokenRedisTemplate&quot;)
    public RedisTemplate&lt;String, String&gt; getTokenRedisTemplate() {
        return buildRedisTemplateByDataBase(10);
    }

    private RedisTemplate&lt;String, String&gt; buildRedisTemplateByDataBase(Integer dataBase) {
        RedisTemplate&lt;String, String&gt; template = new StringRedisTemplate();
        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
        redisStandaloneConfiguration.setHostName(&quot;localhost&quot;);
        redisStandaloneConfiguration.setPort(6379);
        redisStandaloneConfiguration.setDatabase(dataBase);
        JedisClientConfiguration.JedisClientConfigurationBuilder clientConfiguration = JedisClientConfiguration.builder();
        clientConfiguration.connectTimeout(Duration.ofSeconds(60));
        JedisConnectionFactory codeFactory = new JedisConnectionFactory(redisStandaloneConfiguration,
                clientConfiguration.build());
        template.setConnectionFactory(codeFactory);
        template.setValueSerializer(new StringRedisSerializer());
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new StringRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}

</code></pre>
<h4 id="跨域配置">跨域配置</h4>
<p>  一般使用token的都是前后端分离，跨域这个问题总是要解决。springboot框架自带跨域的filter的配置，但是那个配置有些时候老是会有问题，我建议自己配置filter的方式来增加跨域的支持。</p>
<pre><code>package com.auth.frame.security.processor;

import org.springframework.web.bind.annotation.RequestMethod;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @ClassName CROSFilter
 * @Author WFS
 * @Date 2020/2/7/0007 16:58
 */
public class CORSFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String origin = request.getHeader(&quot;Origin&quot;);
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
        response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);
        response.addHeader(&quot;Access-Control-Allow-Headers&quot;,
                &quot;Content-Type, Authorization&quot;);
        response.addHeader(&quot;Access-Control-Allow-Credentials&quot;,
                &quot;true&quot;);
        if (RequestMethod.OPTIONS.toString().equals(request.getMethod())) {
            servletResponse.getWriter().println(&quot;ok&quot;);
            return;
        }
        filterChain.doFilter(request ,response);
    }

    @Override
    public void init(FilterConfig filterConfig) {

    }

    @Override
    public void destroy() {

    }
}
</code></pre>
<p>注册Filter</p>
<pre><code>package com.auth.frame.security.config;

import com.auth.frame.security.processor.CORSFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @ClassName FilterConfig
 * @Author WFS
 * @Date 2020/2/7/0007 16:57
 */
@Configuration
public class FilterConfig {
    @Bean(name = &quot;CORSFilter&quot;)
    public FilterRegistrationBean&lt;CORSFilter&gt; setFilter() {
        FilterRegistrationBean&lt;CORSFilter&gt; filterBean = new FilterRegistrationBean&lt;&gt;();
        filterBean.setFilter(new CORSFilter());
        filterBean.setOrder(Integer.MIN_VALUE);
        filterBean.setName(&quot;CORSFilter&quot;);
        filterBean.addUrlPatterns(&quot;/*&quot;);
        return filterBean;
    }
}

</code></pre>
<blockquote>
<ol>
<li>其余的选项可以按照自己的需求配置filter</li>
<li>filterBean.setOrder(Integer.MIN_VALUE); 保证了filter 第一个执行。</li>
</ol>
</blockquote>
<h2 id="原理">原理</h2>
<ol>
<li>
<h4 id="token-登陆">token 登陆</h4>
</li>
</ol>
<p>  spring security是由一大批filter组成，其中<code>UsernamePasswordAuthenticationFilter</code>是用户登陆验证时候的filter，我们要做的就是登陆验证之前检验token，如果token符合我们规则，那么从token里面取出授权信息，然后在<code>SecurityContextHolder</code>里面增加授权信息。这样，后面经过<code>UsernamePasswordAuthenticationFilter</code>时就不会使用自带的登陆验证逻辑检验。如果token不符合规则，直接滤过，<code>UsernamePasswordAuthenticationFilter</code>检验没有授权信息，会引导到登陆页面。</p>
<ol start="2">
<li>
<h4 id="自定义用户权限">自定义用户权限</h4>
</li>
</ol>
<p>  自定义用户权限主要用户来配合token做权限判断，从token里面取出来的授权信息就是关联我们的自定义权限。要实现自定义权限我们需要实现三个接口：<code>UserDetailsService</code>，该接口主要获取用户对应的权限；<code>FilterInvocationSecurityMetadataSource</code>启动项目时候所有url的权限信息；<code>AccessDecisionManager</code>投票器，根据用户的权限信息和url权限信息来实现允许或者拒绝的逻辑。</p>
<h2 id="用户信息表">用户信息表</h2>
<ol>
<li>
<h4 id="用户表">用户表</h4>
</li>
</ol>
<pre><code>package com.auth.frame.security.bean;


import com.auth.frame.common.BaseEntity;
import lombok.*;

import javax.persistence.*;
import java.util.Set;


@EqualsAndHashCode(callSuper = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;t_sys_user&quot;, indexes = {@Index(columnList = &quot;id&quot;), @Index(columnList = &quot;phoneNum&quot;)})
public class User extends BaseEntity {
    @Column(unique = true)
    private String phoneNum;
    @Column(unique = true)
    private String userName;
    @Column
    private String salt;
    @Column
    private String passWord;
    @Column
    private Boolean accountNonExpired;
    @Column
    private Boolean accountNonLocked;
    @Column
    private Boolean credentialsNonExpired;
    @Column
    private Boolean enabled;
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = &quot;t_sys_user_role&quot;, joinColumns = {@JoinColumn(name = &quot;user_id&quot;, referencedColumnName = &quot;id&quot;)}
            , inverseJoinColumns = {@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)})
    private Set&lt;Role&gt; roles;

}
</code></pre>
<ol start="2">
<li>
<h4 id="角色表">角色表</h4>
</li>
</ol>
<pre><code>package com.auth.frame.security.bean;

import com.auth.frame.common.BaseEntity;
import lombok.*;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Index;
import javax.persistence.Table;

@EqualsAndHashCode(callSuper = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;t_sys_role&quot;, indexes = {@Index(columnList = &quot;id&quot;)})
public class Role extends BaseEntity {
    @Column
    private String name;
    @Column
    private String auth;
}
</code></pre>
<ol start="3">
<li>
<h4 id="url表">URL表</h4>
</li>
</ol>
<pre><code>package com.auth.frame.security.bean;


import com.auth.frame.common.BaseEntity;
import lombok.*;

import javax.persistence.*;
import java.util.Set;


@EqualsAndHashCode(callSuper = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;t_sys_url&quot;, indexes = {@Index(columnList = &quot;id&quot;)})
public class URL extends BaseEntity {
    @Column
    private String name;
    @Column
    private String path;

    @ManyToMany (fetch = FetchType.EAGER)
    @JoinTable(name = &quot;t_sys_url_role&quot;, joinColumns = {@JoinColumn(name = &quot;url_id&quot;, referencedColumnName = &quot;id&quot;)}
            , inverseJoinColumns = {@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)})
    private Set&lt;Role&gt; roles;
}
</code></pre>
<blockquote>
<ol>
<li>BaseEntity 主要是提供主键和创建、修改时间的字段。</li>
<li>注解中使用了 lombok。</li>
<li>角色、用户和URL使用的是单边对应，如有需要可改为多边对应。</li>
</ol>
</blockquote>
<h2 id="自定义认证">自定义认证</h2>
<ol>
<li>
<h4 id="userdetails">UserDetails</h4>
</li>
</ol>
<p>  UserDetails是spring security中的用户信息接口，通过实现UserDetails可以和User表关联起来。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.security.bean.User;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;

/**
 * @ClassName CSTUserDetailService
 * @Author WFS
 * @Date 2020/1/21 10:39
 */
@NoArgsConstructor
@AllArgsConstructor
@Data
public class CSTUserDetails implements UserDetails {
    private Collection&lt;SimpleGrantedAuthority&gt; authorities;
    private String username;
    private String userId;
    private Boolean accountNonExpired;
    private Boolean accountNonLocked;
    private Boolean credentialsNonExpired;
    private Boolean enabled;

    public CSTUserDetails(Collection&lt;SimpleGrantedAuthority&gt; authorities, String username, String userId, boolean accountNonExpired, boolean accountNonLocked, boolean credentialsNonExpired, boolean enabled) {
        this.authorities = authorities;
        this.username = username;
        this.userId = userId;
        this.accountNonExpired = accountNonExpired;
        this.accountNonLocked = accountNonLocked;
        this.credentialsNonExpired = credentialsNonExpired;
        this.enabled = enabled;
    }

    public CSTUserDetails(User user) {
        this.authorities = CSTUserDetailsService.getAuthorities(user);
        this.username = user.getUserName();
        this.userId = user.getId();
        this.accountNonExpired = user.getAccountNonExpired();
        this.accountNonLocked = user.getAccountNonLocked();
        this.credentialsNonExpired = user.getCredentialsNonExpired();
        this.enabled = user.getEnabled();
    }


    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return null;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return accountNonExpired;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return credentialsNonExpired;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}
</code></pre>
<blockquote>
<p><code>authorities</code>是用户对应的权限，其实就是一个字符串列表，可以自行拓展。</p>
</blockquote>
<ol start="2">
<li>
<h4 id="userdetailsservice">UserDetailsService</h4>
</li>
</ol>
<p>  UserDetailsService接口规定了通过用户名获取用户信息的接口，即获取UserDetails。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.security.bean.Role;
import com.auth.frame.security.bean.User;
import com.auth.frame.security.service.UserService;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * @ClassName CSTUserDetailsService
 * @Author WFS
 * @Date 2020/1/21 10:50
 */
@Component
public class CSTUserDetailsService implements UserDetailsService {


    private final UserService userService;

    public CSTUserDetailsService(UserService userService) {
        this.userService = userService;
    }

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        User user = userService.getCacheUser(s);
        if (user == null) {
            throw new UsernameNotFoundException(&quot;User Not Find!&quot;);
        } else {
            Collection&lt;SimpleGrantedAuthority&gt; authorities = getAuthorities(user);
            return new CSTUserDetails(authorities, user.getUserName(), user.getId(), user.getAccountNonExpired(), user.getAccountNonLocked(), user.getCredentialsNonExpired(), user.getEnabled());
        }
    }

    public static Collection&lt;SimpleGrantedAuthority&gt; getAuthorities(User user) {
        Set&lt;Role&gt; roleSet = user.getRoles();
        Collection&lt;SimpleGrantedAuthority&gt; authorities = new HashSet&lt;&gt;();
        if (roleSet != null &amp;&amp; !roleSet.isEmpty()) {
            roleSet.forEach(role -&gt; authorities.add(new SimpleGrantedAuthority(role.getAuth())));
        }
        return authorities;
    }
}
</code></pre>
<blockquote>
<p><code>loadUserByUsername</code>函数中的参数<code>s</code>即为用户名，<code>userService.getCacheUser</code>的作用是根据用户名获取用户，此处使用的自己写的从缓存获取用户名，可以自由发挥，只要能构建<code>UserDetails</code>即可。</p>
</blockquote>
<ol start="3">
<li>
<h4 id="filterinvocationsecuritymetadatasource">FilterInvocationSecurityMetadataSource</h4>
</li>
</ol>
<p>  <code>FilterInvocationSecurityMetadataSource</code>元数据，接口获取的是全部URL的权限信息和当http请求过来时候url对应的权限。其中<code>getAttributes</code>的参数<code>o</code>包含了当前访问的URL，根据URL我们需要返回对应的权限信息；<code>getAllConfigAttributes</code>会在项目启动时执行一次，获取所有URL对应的权限信息。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.security.bean.Role;
import com.auth.frame.security.repository.RoleRepository;
import com.auth.frame.security.service.URLService;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.access.SecurityConfig;
import org.springframework.security.web.FilterInvocation;
import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import static com.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE;

/**
 * @ClassName CSTSecurityMetadataSource
 * @Author WFS
 * @Date 2020/1/21 17:06
 */
public class CSTSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {

    private URLService urlService;

    private RoleRepository roleRepository;

    public CSTSecurityMetadataSource(URLService urlService, RoleRepository roleRepository) {
        this.urlService = urlService;
        this.roleRepository = roleRepository;
    }

    @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException {
        String url = ((FilterInvocation) o).getRequestUrl();
        Collection&lt;ConfigAttribute&gt; configAttributes = new HashSet&lt;&gt;();
        Set&lt;Role&gt; roles = urlService.getCacheURL(url);
        roles.forEach(ele -&gt; configAttributes.add(new SecurityConfig(ele.getAuth())));
        if (configAttributes.isEmpty()) {
            configAttributes.add(new SecurityConfig(DEFAULT_ROLE));
        }
        return configAttributes;
    }

    @Override
    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() {
        Collection&lt;ConfigAttribute&gt; configAttributes = new HashSet&lt;&gt;();
        roleRepository.findAllByDeletedIsFalse().forEach(e -&gt; configAttributes.add(new SecurityConfig(e.getAuth())));
        return configAttributes;
    }

    @Override
    public boolean supports(Class&lt;?&gt; aClass) {
        return true;
    }
}
</code></pre>
<ol start="4">
<li>
<h4 id="accessdecisionmanager">AccessDecisionManager</h4>
</li>
</ol>
<p>  投票管理器，接口规定了用户权限和URL权限之间的逻辑，即满足某种情况拒绝或者允许。</p>
<pre><code>package com.auth.frame.security.processor;

import org.springframework.security.access.AccessDecisionManager;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.Authentication;

import java.util.Collection;

import static com.auth.frame.security.config.ConstValue.ROLE.DEFAULT_ROLE;

/**
 * @ClassName CSTAccessDecisionManager
 * @Author WFS
 * @Date 2020/1/21 17:06
 */
public class CSTAccessDecisionManager implements AccessDecisionManager {
    @Override
    public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException {
        if (collection.size() == 1 &amp;&amp; collection.stream().anyMatch(ele -&gt; DEFAULT_ROLE.equals(ele.getAttribute()))) {
            return;
        }
        if (!collection.stream().allMatch(ele -&gt; authentication.getAuthorities().stream().anyMatch(e -&gt; ele.getAttribute().equals(e.getAuthority())))) {
            throw new AccessDeniedException(&quot;AccessDenied!&quot;);
        }
    }

    @Override
    public boolean supports(ConfigAttribute configAttribute) {
        return Boolean.TRUE;
    }

    @Override
    public boolean supports(Class&lt;?&gt; aClass) {
        return Boolean.TRUE;
    }
}
</code></pre>
<p>  <code>Authentication</code>中包含有用户的权限信息，<code>Collection&lt;ConfigAttribute&gt;</code>包含有当前URL需要的权限信息，根据这两个参数我们就可以自由的指定我们投票规则。比如：某个URL含有多个权限，某个用户只要拥有其中一个就可以访问，或者要求必须全部拥有对应的权限才可以访问，此处可以自由发挥。需要注意的是，<strong><code>AccessDecisionManager</code>不起作用的情况，原因是如果<code>Collection&lt;ConfigAttribute&gt;</code>为<code>null</code>或者<code>empty</code>，则不会执行投票器，所以我们需要给没有配置权限的URL一个默认权限。</strong></p>
<h2 id="tokenfilter">tokenFilter</h2>
<p>  tokenFilter主要用来检查是否登陆的逻辑。先从请求里面获取token，解密，然后从reids里面获取相关权限信息；如果没有token则检查是否是用户名和密码，如果存在那么验证用户名和密码是否匹配，然后生成授权信息，存入redis，返回token给前端。</p>
<pre><code>package com.auth.frame.security.processor;

import com.auth.frame.common.ResponseEntity;
import com.auth.frame.common.Utils.JSONUtil;
import com.auth.frame.common.Utils.StringUtil;
import com.auth.frame.security.Utils.TokenUtil;
import com.auth.frame.security.bean.User;
import com.auth.frame.security.repository.UserRepository;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.util.DigestUtils;

import javax.annotation.Resource;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * @ClassName TokenFilter
 * @Author WFS
 * @Date 2020/1/21 10:47
 */
@Component
public class TokenFilter implements Filter {


    private final UserRepository userRepository;

    @Resource(name = &quot;sysTokenRedisTemplate&quot;)
    public RedisTemplate&lt;String, String&gt; redisTemplate;

    private static final String usernameParameter = &quot;username&quot;;
    private static final String passwordParameter = &quot;password&quot;;

    public TokenFilter(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public void init(FilterConfig filterConfig) {

    }

    @Override
    public void destroy() {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String rds = TokenUtil.getBody(request);
        if (rds == null) {
            String username = request.getParameter(usernameParameter);
            String password = request.getParameter(passwordParameter);
            if (!StringUtil.isNullOrEmpty(username, password)) {
                User user = userRepository.findByDeletedIsFalseAndUserName(username);
                if (user != null) {
                    if (user.getAccountNonExpired() &amp;&amp; user.getAccountNonLocked() &amp;&amp; user.getCredentialsNonExpired() &amp;&amp; user.getEnabled()) {
                        if (!StringUtil.isNullOrEmpty(user.getSalt(), user.getPassWord())) {
                            if (user.getPassWord().equals(DigestUtils.md5DigestAsHex((password + user.getSalt()).getBytes(StandardCharsets.UTF_8)))) {
                                Set&lt;String&gt; rdsSet = redisTemplate.keys(&quot;*&quot;);
                                if (rdsSet != null) {
                                    for (String s : rdsSet) {
                                        String rc = redisTemplate.opsForValue().get(s);
                                        if (rc != null) {
                                            CSTUserDetails rc_u = JSONUtil.json2Obj(rc, CSTUserDetails.class);
                                            if (rc_u != null) {
                                                if (user.getId().equals(rc_u.getUserId())) {
                                                    redisTemplate.delete(s);
                                                }
                                            }
                                        }
                                    }
                                }
                                CSTUserDetails cstUserDetails = new CSTUserDetails(user);
                                String r = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);
                                redisTemplate.opsForValue().set(r, JSONUtil.obj2Json(cstUserDetails));
                                redisTemplate.expire(r, 2, TimeUnit.HOURS);
                                String token = TokenUtil.create(r);
                                ResponseEntity.ofToken(response, token);
                                return;
                            }
                        }
                    }
                }
            }
        } else {
            String cuStr = redisTemplate.opsForValue().get(rds);
            if (!StringUtil.isNullOrEmpty(cuStr)) {
                CSTUserDetails cu = JSONUtil.json2Obj(cuStr, CSTUserDetails.class);
                if (cu != null) {
                    if (cu.getAccountNonExpired() &amp;&amp; cu.getAccountNonLocked() &amp;&amp; cu.getCredentialsNonExpired() &amp;&amp; cu.getEnabled()) {
                        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(cu.getUserId(), cu.getPassword(), cu.getAuthorities()));
                    }
                }
            }
        }
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
</code></pre>
<blockquote>
<ol>
<li><code>TokenUtil</code> 主要从<code>request</code>里面解析<code>token</code>里面的<code>rds</code></li>
<li>中间有一段<code>redis</code>的操作，此处可以自行拓展，即每一个新的附带密码的请求都去删除<code>redis</code>里面相同<code>userId</code>的授权信息，这样做的好处是可以保证每个账号同一个时间只有一个人登陆。</li>
<li><code>ResponseEntity.ofToken()</code> 工具类，用于向<code>response</code>返回信息</li>
</ol>
</blockquote>
<h2 id="配置spring-security">配置<code>spring security</code></h2>
<p>  设置<code>withObjectPostProcessor</code>来设置<code>AccessDecisionManager</code>和<code>SecurityMetadataSource</code>，<code>addFilterBefore</code>设置<code>TokenFilter</code>的位置，<code>web.ignoring</code>设置开放<code>API</code>的路径，开放<code>API</code>不受<code>spring security</code>过滤链的控制。</p>
<pre><code>package com.auth.frame.security.config;

import com.auth.frame.security.processor.CSTAccessDecisionManager;
import com.auth.frame.security.processor.CSTSecurityMetadataSource;
import com.auth.frame.security.processor.CSTUserDetailsService;
import com.auth.frame.security.processor.TokenFilter;
import com.auth.frame.security.repository.RoleRepository;
import com.auth.frame.security.service.URLService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.ObjectPostProcessor;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.access.intercept.FilterSecurityInterceptor;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsUtils;

/**
 * @ClassName SecurityConfig
 * @Author WFS
 * @Date 2020/1/21 10:25
 */
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {


    private final CSTUserDetailsService cstUserDetailsService;
    private final ApplicationSecurityConfig applicationSecurityConfig;
    private final TokenFilter tokenFilter;

    private final URLService urlService;
    private final RoleRepository roleRepository;


    public SecurityConfig(CSTUserDetailsService cstUserDetailsService, ApplicationSecurityConfig applicationSecurityConfig, TokenFilter tokenFilter, URLService urlService, RoleRepository roleRepository) {
        this.cstUserDetailsService = cstUserDetailsService;
        this.applicationSecurityConfig = applicationSecurityConfig;
        this.tokenFilter = tokenFilter;
        this.urlService = urlService;
        this.roleRepository = roleRepository;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(cstUserDetailsService);
    }

    @Bean
    public CSTAccessDecisionManager getCSTAccessDecisionManager() {
        return new CSTAccessDecisionManager();
    }

    @Bean
    public CSTSecurityMetadataSource getCSTSecurityMetadataSource() {
        return new CSTSecurityMetadataSource(urlService, roleRepository);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().cors()
                .and().authorizeRequests()
                .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
                    @Override
                    public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) {
                        o.setAccessDecisionManager(getCSTAccessDecisionManager());
                        o.setSecurityMetadataSource(getCSTSecurityMetadataSource());
                        return o;
                    }
                })
                .requestMatchers(CorsUtils::isPreFlightRequest).permitAll()
                .anyRequest().authenticated()
                .and().anonymous().disable().formLogin().permitAll()
                .and().addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class)
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }

    @Override
    public void configure(WebSecurity web) {
        web.ignoring().regexMatchers(applicationSecurityConfig.getOpenApi());
    }
}
</code></pre>
<h2 id="结语">结语</h2>
<p>  通过以上逻辑，token登陆和自定义权限功能已经完成，其实所有的功能实现集中于<code>UserDetails</code>的构建和<code>AccessDecisionManager</code>投票逻辑，熟知于此就可以随意拓展Filter来实现自己的功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[excel强制启用VBA]]></title>
        <id>http://fikacode.github.io/post/excelForceEnableVba/</id>
        <link href="http://fikacode.github.io/post/excelForceEnableVba/">
        </link>
        <updated>2020-12-30T09:28:22.000Z</updated>
        <content type="html"><![CDATA[<p>事实上VBA的启用依赖于运行的容器，VBA本身没有强制启用的功能。但是我们可以用另外一种方法来实现 强制启用的功能：如果不启用那么，显示一个页面，提示启用；如果启用就隐藏提示，显示正文。<br>
大概代码如下：</p>
<pre><code>Private Sub Workbook_BeforeClose(Cancel As Boolean)
    Dim sh AsWorksheet
    ForEach sht In Worksheets
        If sht.Name&lt;&gt;”Welcome”Then
           Sheets(sht.Name).Visible= False
        End If
    Next
    Sheets(“Welcome”).Visible= True
    Sheets(“Welcome”).Select
    ThisWorkbook.Save
End Sub
Private Sub Workbook_Open()
    Dim sht AsWorksheet
    ForEach sht In Worksheets
        If sht.Name&lt;&gt;”Welcome” Then
            sht.Visible = xlSheetVisible
        End If
    Next
    Worksheets(“Welcome”).Visible= xlSheetVeryHidden
    ThisWorkbook.Save
End Sub
</code></pre>
<p>代码很好理解：关闭之前，隐藏所有sheet，只显示Welcome；打开文件隐藏Welcome，显示正文。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring boot 打包为外置 tomcat (war)]]></title>
        <id>http://fikacode.github.io/post/springbootPackageToWar/</id>
        <link href="http://fikacode.github.io/post/springbootPackageToWar/">
        </link>
        <updated>2020-12-30T08:43:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="修改pom文件">修改pom文件</h2>
<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;!-- 移除嵌入式tomcat插件 --&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="修改application启动类">修改Application启动类</h2>
<h4 id="修改前">修改前</h4>
<pre><code>public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<h4 id="修改后">修改后</h4>
<pre><code>public class Application extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return builder.sources(Application.class);
    }
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<h2 id="特别注意">特别注意</h2>
<h4 id="如果使用了-websocket那么需要注释掉下面的代码同时添加websocket的支持">如果使用了 <code>websocket</code>，那么需要注释掉下面的代码，同时添加<code>websocket</code>的支持。</h4>
<pre><code>@Configuration
public class WebSocketConfig {
//    @Bean
//    public ServerEndpointExporter serverEndpointExporter() {
//        return new ServerEndpointExporter();
//    }
}
</code></pre>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/javax.websocket/javax.websocket-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.websocket&lt;/groupId&gt;
    &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="如果使用了注解webfilter那么需要使用filterregistrationbean的方式来注册filter">如果使用了注解<code>@WebFilter</code>，那么需要使用<code>FilterRegistrationBean</code>的方式来注册<code>Filter</code>。</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tomcat 常用的优化]]></title>
        <id>http://fikacode.github.io/post/tomcatOptimizationAndCache/</id>
        <link href="http://fikacode.github.io/post/tomcatOptimizationAndCache/">
        </link>
        <updated>2020-12-30T08:39:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="catalina-设置-java-参数">catalina 设置 java 参数</h4>
<pre><code>set CATALINA_OPTS=-Dfile.encoding=UTF-8 -server -Xms8192m -Xmx8192m -Xmn4096m -XX:SurvivorRatio=10 -XX:MaxTenuringThreshold=15 -XX:NewRatio=2 -XX:+DisableExplicitGC
</code></pre>
<blockquote>
<p>根据环境的配置优化相关参数</p>
</blockquote>
<h4 id="serverxml-设置连接池">Server.xml 设置连接池</h4>
<pre><code>    &lt;Executor 
       name=&quot;tomcatThreadPool&quot; 
       namePrefix=&quot;catalina-exec-&quot;
       maxThreads=&quot;500&quot; 
       minSpareThreads=&quot;100&quot; 
       prestartminSpareThreads = &quot;true&quot;
       maxQueueSize = &quot;100&quot;
    /&gt;
</code></pre>
<h4 id="开启压缩和-nio2">开启压缩和 NIO2</h4>
<pre><code>  &lt;Connector 
    	executor=&quot;tomcatThreadPool&quot;
   	port=&quot;80&quot; 
   	protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot; 
   	connectionTimeout=&quot;20000&quot; 
   	maxConnections=&quot;10000&quot; 
   	redirectPort=&quot;8443&quot; 
   	enableLookups=&quot;false&quot; 
   	acceptCount=&quot;100&quot; 
   	maxPostSize=&quot;10485760&quot; 
   	compression=&quot;on&quot; 
   	disableUploadTimeout=&quot;true&quot; 
   	compressionMinSize=&quot;50&quot; 
   	acceptorThreadCount=&quot;4&quot; 
   	compressableMimeType=&quot;text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/x-javascript,application/json,image/jpg,application/x-font-ttf,application/x-font-otf,image/svg+xml,image/jpeg,image/png,image/gif,audio/mpeg,video/mp4,font/woff&quot; 
   	URIEncoding=&quot;utf-8&quot;
     /&gt;
</code></pre>
<h4 id="webxml-设置缓存">web.xml 设置缓存</h4>
<pre><code>&lt;filter&gt;
 &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 &lt;filter-class&gt;org.apache.catalina.filters.ExpiresFilter&lt;/filter-class&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType image&lt;/param-name&gt;
    &lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType text&lt;/param-name&gt;
    &lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType application/javascript&lt;/param-name&gt;
    &lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType multipart/form-data&lt;/param-name&gt;
    &lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType font/woff&lt;/param-name&gt;
    &lt;param-value&gt;access plus 30 days&lt;/param-value&gt;
 &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
 &lt;filter-name&gt;ExpiresFilter&lt;/filter-name&gt;
 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 将数组均分为多个数组]]></title>
        <id>http://fikacode.github.io/post/javaListAverage/</id>
        <link href="http://fikacode.github.io/post/javaListAverage/">
        </link>
        <updated>2020-12-30T03:25:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="将一组数据平均分成n组">将一组数据平均分成n组</h4>
<pre><code>/**
 * 将一组数据平均分成n组
 *
 * @param source 要分组的数据源
 * @param n      平均分成n组
 * @param &lt;T&gt;
 * @return
 */
public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; averageAssign(List&lt;T&gt; source, int n) {
    List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;();
    int remainder = source.size() % n;  //(先计算出余数)
    int number = source.size() / n;  //然后是商
    int offset = 0;//偏移量
    for (int i = 0; i &lt; n; i++) {
        List&lt;T&gt; value = null;
        if (remainder &gt; 0) {
            value = source.subList(i * number + offset, (i + 1) * number + offset + 1);
            remainder--;
            offset++;
        } else {
            value = source.subList(i * number + offset, (i + 1) * number + offset);
        }
        result.add(value);
    }
    return result;
}
</code></pre>
<h4 id="将一组数据固定分组每组n个元素">将一组数据固定分组，每组n个元素</h4>
<pre><code>/**
 * 将一组数据固定分组，每组n个元素
 * @param source 要分组的数据源
 * @param n      每组n个元素
 * @param &lt;T&gt;
 * @return
 */
public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; fixedGrouping(List&lt;T&gt; source, int n) {

    if (null == source || source.size() == 0 || n &lt;= 0)
        return null;
    List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;();

    int sourceSize = source.size();
    int size = (source.size() / n) + 1;
    for (int i = 0; i &lt; size; i++) {
        List&lt;T&gt; subset = new ArrayList&lt;T&gt;();
        for (int j = i * n; j &lt; (i + 1) * n; j++) {
            if (j &lt; sourceSize) {
                subset.add(source.get(j));
            }
        }
        result.add(subset);
    }
    return result;
}
</code></pre>
<h4 id="将一组数据固定分组每组n个元素-2">将一组数据固定分组，每组n个元素</h4>
<pre><code>/**
 * 将一组数据固定分组，每组n个元素，第二种写法
 *
 * @param source 要分组的数据源
 * @param n      每组n个元素
 * @param &lt;T&gt;
 * @return
 */
public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; fixedGrouping2(List&lt;T&gt; source, int n) {

    if (null == source || source.size() == 0 || n &lt;= 0)
        return null;
    List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;();
    int remainder = source.size() % n;
    int size = (source.size() / n);
    for (int i = 0; i &lt; size; i++) {
        List&lt;T&gt; subset = null;
        subset = source.subList(i * n, (i + 1) * n);
        result.add(subset);
    }
    if (remainder &gt; 0) {
        List&lt;T&gt; subset = null;
        subset = source.subList(size * n, size * n + remainder);
        result.add(subset);
    }
    return result;
}
</code></pre>
]]></content>
    </entry>
</feed>